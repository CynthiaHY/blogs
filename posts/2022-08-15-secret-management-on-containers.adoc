---
layout: post
title: "Secrets management in Kubernetes - using HashiCorp Vault"
categories: blog
author_picture: https://avatars3.githubusercontent.com/shamjithantholi
author_github: https://github.com/shamjithantholi
seo-title: Secrets management in Kubernetes - using HashiCorp Vault
seo-description: How to manage secrets in kubernetes containers - using HashiCorp Vault.
blog_description: How to manage secrets in kubernetes cluster - using HashiCorp Vault.
open-graph-image: https://openliberty.io/img/blog/liberty-devops-generic-architecture.png
---
= Secrets management in Kubernetes - using HashiCorp Vault
Shamjith Antholi <https://github.com/shamjithantholi>
:imagesdir: /
:url-prefix:
:url-about: /

[#Intro]

Secrets are confidential information which is very sensitive in nature and hence it's access are restricted. In general, multiple layers of security are used in storing and retriving secrets like passwords and tokens. Kubernetes/OpenShift has provisions internally to secure the secrets, but in many cases application security team does not prefer to store the secrets permanently on kubernetes cluster to which non-application team will have access. Vendor tools like HashiCorp Vault come to the rescue in such requirements. 

== Hashicorp Vault and Kubernetes

HashiCorp vault is a secret management tool which help organisations to store and transmit secrets securely. Identity based access to HashiCorp vault are controlled by well defined HashiCorp Configuration Language (HCL) based 'Policies'. Role-based access control (RBAC) based policies are used for comtrolling human access and Dynamically generated secret based access control are used to authenticate machine access. Vault provides “encryption as a service,” encrypting data in transit (with TLS) and at rest (using AES 256-bit CBC encryption) and hence vault make sure that data is encrypted always. 

This blog is focused on hosting Hashicorp vault server in Kubernetes and also how to securly access vault secrets on kubernetes pods. Kubernetes is a open source platform for managing containerized applications workloads and services that facilitates both declarative configuration and automation. Kubernetes works with Docker runtime engine as well as other wide variety of container engines. Kubernetes cluster can be installed on your own datacenter ( link:https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/[Install kubernetes] ) or directly use a host kubernetes service (eg: link:https://azure.microsoft.com/en-us/services/kubernetes-service/ [Azure kubernetes service] )

#Kubernetes - HashiCorp integration architecture diagram

=== Install Helm chart

Vault community is maintaining Helm chart for vault, install latest version of HELM follow the steps in link:https://helm.sh/docs/intro/install/[Helm installation steps] +
Add HashiCorp to the helm repository using the command "helm repo add hashicorp https://helm.releases.hashicorp.com"

== HashiCorp vault server setup steps on Kubernetes

In this section i will explain the installation steps of Vault server, associated storage cluster and security certificates on Kubernetes cluster.    

=== Consule storage setup

As the first step, we need to setup a backened storage repository for vault to store the secrets. We will setup a single instance link:https://www.consul.io server for this purpose (Consul is a default storage solution for vault, other compatible options like k8s volume can also be used for this purpose). +
Find out the latest version of Consul avilable in helm and install it on kubernetes using the below give commands. Before that, create a consule properties file in yaml format

                global:
                    datacenter: vault-blog
                client:
                    enabled: true
                server:
                    replicas: 1
                    bootstrapExpect: 1
                    disruptionBudget:
                        maxUnavailable: 0

                helm search repo hashicorp/consul --versions
                helm template consul hashicorp/consul --namespace vault --version <latest-consul-version> -f consul-values.yaml > consul.yaml
                # Note: correct the 'apiVersion' of 'PodDisruptionBudget' to 'policy/v1' (if wrong) 
                # Note: check if your pod has permission to the path in "data_dir", for test purpose modify it to "data_dir" : "/tmp/consul/data",    
                kubectl create ns vault
                kubectl -n vault apply -f consul.yaml

The result should look like this

image::/img/blog/consul-server-status.png[Consul server status  ,width=50%,align="center"]

=== TLS setup

Now we will work on TLS certificate creation for enbling all vault communication's to be encrypted (we will using self signed certificates for this blog, or can use your own certificate, you can skip the below given steps if you are bringing your own certificate).

First step is to create 2 json files with certificate properties and certificate signing request (attached below).

            config.json

            {
                "signing": {
                    "default": {
                    "expiry": "2232h"
                    },
                    "profiles": {
                    "default": {
                        "usages": ["signing", "key encipherment", "server auth", "client auth"],
                        "expiry": "2232h"
                        }
                    }
                }
            }

            csr.json

            {
                "hosts": [
                    "cluster.local"
                ],
                "key": {
                    "algo": "rsa",
                    "size": 2048
                },
                "names": [
                    {
                    "C": "AU",
                    "L": "Melbourne",
                    "O": "Example",
                    "OU": "CA",
                    "ST": "Example"
                    }
                ]
            }

First step is making available cloudflare binaries to generate the self signed certificate and also to work with json files. You can either use your own linux/windows machine for generating certificates or create a lightweight container for the same, i am using a lightweight container here for the purpose 

                docker run -it --rm -v ${PWD}:/tmp -w /tmp debian bash  # This command is mapping the current directory which contains certificate properties file

                apt-get update && apt-get install -y curl &&
                curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssl_1.6.1_linux_amd64 -o /usr/local/bin/cfssl && \
                curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.1/cfssljson_1.6.1_linux_amd64 -o /usr/local/bin/cfssljson && \
                chmod +x /usr/local/bin/cfssl && \
                chmod +x /usr/local/bin/cfssljson       

Generate the CA certificate using CSR

            cfssl gencert -initca ca-csr.json | cfssljson -bare /tmp/ca

generate the vault certificate using CA certificate and other properties file

            cfssl gencert \
            -ca=/tmp/ca.pem \
            -ca-key=/tmp/ca-key.pem \
            -config=ca-config.json \
            -hostname="vault,vault.vault.svc.cluster.local,vault.vault.svc,localhost,127.0.0.1" \
            -profile=default \
            ca-csr.json | cfssljson -bare /tmp/vault 

Exit the container, the generated files will be available in the current folder

Create the CA and vault TLS secrets in Kubernetes cluster

            kubectl -n vault create secret tls tls-ca \
            --cert ./tls/ca.pem  \
            --key ./tls/ca-key.pem

            kubectl -n vault create secret tls tls-server \
            --cert ./tls/vault.pem \
            --key ./tls/vault-key.pem

=== Vault server installation and initialization

First step is to create a configuration yaml file with all the custom property values required by the vault server while installation (overriding default values of helm chart installer file), a sample file is given below, please modify values according to your preference

            vault-config.yaml

            # Vault Helm Chart Value Overrides
            global:
            enabled: true
            tlsDisable: false

            injector:
            enabled: true
            # Use the Vault K8s Image https://github.com/hashicorp/vault-k8s/
            image:
                repository: "hashicorp/vault-k8s"
                tag: "latest"

            resources:
                requests:
                    memory: 50Mi
                    cpu: 50m
                limits:
                    memory: 256Mi
                    cpu: 250m

            server:
            image:
                repository: "hashicorp/vault"
                tag: "latest"

            # These Resource Limits are in line with node requirements in the
            # Vault Reference Architecture for a Small Cluster
            resources:
                requests:
                memory: 50Mi
                cpu: 500m
                limits:
                memory: 4Gi
                cpu: 2000m

            # For HA configuration and because we need to manually init the vault,
            # we need to define custom readiness/liveness Probe settings
            readinessProbe:
                enabled: true
                path: "/v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204"
            livenessProbe:
                enabled: true
                path: "/v1/sys/health?standbyok=true"
                initialDelaySeconds: 60

            # extraEnvironmentVars is a list of extra environment variables to set with the stateful set. These could be
            # used to include variables required for auto-unseal.
            extraEnvironmentVars:
                VAULT_CACERT: /vault/userconfig/tls-ca/tls.crt

            # extraVolumes is a list of extra volumes to mount. These will be exposed
            # to Vault in the path `/vault/userconfig/<name>/`.
            extraVolumes:
                - type: secret
                name: tls-server
                - type: secret
                name: tls-ca

            standalone:
                enabled: false

            # Run Vault in "HA" mode.
            ha:
                enabled: true
                replicas: 2
                config: |
                ui = true

                listener "tcp" {
                    tls_disable = 0
                    address     = "0.0.0.0:8200"
                    tls_cert_file = "/vault/userconfig/tls-server/tls.crt"
                    tls_key_file = "/vault/userconfig/tls-server/tls.key"
                    tls_min_version = "tls12"
                }

                storage "consul" {
                    path = "vault"
                    address = "consul-consul-server:8500"
                }
                # Vault UI
                ui:
                enabled: true
                externalPort: 8200

Generate the vault deployment config using the vault-config yaml create above, i am using the latest latest images (when this blog is writtent) of all required images 

            helm template vault hashicorp/vault --namespace vault --version  0.20.1  -f vault-values.yaml > ./vault.yaml
            kubectl -n vault apply -f ./vault.yaml

The pod status should look like this,

image::/img/blog/vault-server-pod-status.png[Vault server pod status  ,width=50%,align="center"]

But even at this point, vault is not ready to serve the customers, we are going to initialize the vault server with next few steps

            # connect to one of the vault pod
            kubectl -n vault exec -it vault-0 -- sh

            #run the command to get the keys
            vault operator init

Save all the 'Unseal key' and 'Initial Root Token'

Start unsealing the vault by running below given command
            vault operator unseal

Run this command multiple times and provide separate keys everytime to unseal until the 'Sealed' status is false

image::/img/blog/vault-unseal-status.png[Vault unseal status  ,width=50%,align="center"]

*Important:* Run the same steps on all vault pod instances

Run the below given steps to access the UI (this is for test purpose only, in production grade installation, you can follow load balancer or other mapping steps)

            kubectl -n vault get svc
            kubectl -n vault port-forward svc/vault-ui 443:8200 # In case 443 is not working, just use 8200

Login to vault using the URL https://localhost:8200

image::/img/blog/vault-login-page.png[Vault login page  ,width=50%,align="center"]

Use the 'Initial Root Token' saved earlier to login to vault

== HashiCorp vault - kubernetes integration setup steps

=== Authorizing vault injector to access vault

Vault injector pod running along with vault server (eg: pod with name vault-agent-injector-* in this example) need to authorized to access vault to send the secrets to client pods. Execute the below given steps to injector authorization

            kubectl -n vault exec -it vault-0 -- sh 

            vault login
            vault auth enable kubernetes

            vault write auth/kubernetes/config \
            token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
            kubernetes_host=https://${KUBERNETES_PORT_443_TCP_ADDR}:443 \
            kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
            issuer="https://kubernetes.default.svc.cluster.local"
            exit


#setup steps

#How secrets are pull into containers

#How secrets can be used in applications in the containers

#Limitations


== Conclusion

