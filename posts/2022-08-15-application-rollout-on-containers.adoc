---
layout: post
title: "Application rollout strategies in containerization platform"
categories: blog
author_picture: https://avatars3.githubusercontent.com/shamjithantholi
author_github: https://github.com/shamjithantholi
seo-title: Application rollout strategies in containerization platform
seo-description: A short explanation about different application rollout strategies in kubernetes platform.
blog_description: A short explanation about different application rollout strategies in kubernetes platform
open-graph-image: https://openliberty.io/img/blog/liberty-devops-generic-architecture.png
---
= Application rollout strategies in containerization platform
Shamjith Antholi <https://github.com/shamjithantholi>
:imagesdir: /
:url-prefix:
:url-about: /

[#Intro]

A deployment is a process of installing a new version of an application or the associated component. A well defined deployment strategy is important to ensure the smooth transition of application from old version to new version. Various other factors like application downtime are an important factor in deployment process.

On a containerized environment, a 'Deployment' object is the key controller in the deployment. A 'Deployment' is a declarative resource object that defines the desired state for your program. A Deployment object compares the current program state to the desired state, desired state like how many pods are currently running, container image version etc. If they do not match, the Deployment-controller automatically alters the state to match. Kubernetes uses the 'ReplicaSet' to maintain the desired status of the 'Deployment'. If 'Deployment' objects are not used to manage the pod deployments, then the user will have to manually manage any changes in the pods individually, for example, user has to individually check any startup issues on all the pod instances, any rollback has to be managed individually.  

Kubernetes is offering different deployment strategies which can be used based on the business requirements, this blog is discussing below given a few.

              1. Recreate Deployment
              2. Rolling Deployment
              3. Blue/Green Deployment 
              4. Canary Deployment
              5. A/B testing
              6. Shadow deployment

== Rollout strategies explained

=== Recreate Deployment
Recreate deployment strategy use 'all-or-nothing' approach in deployment. In this strategy, all the running container instances are brought down before attempting the new version deployment. In this deployment strategy, the application state is entirely renewed and it's best for development environment. This deployment strategy involves significant application downtime comparing any other deployment strategy. The total application downtime needed should be measured as the duration required to shutdown and reboot the application pods.

The code snippet required to add in deployment yaml to enable this deployment method is as given below

                  spec:
                    replicas: 2
                    strategy:
                      type: Recreate

=== Rolling deployment
Rolling deployment follows the pattern of slowly rolling out a new version of an application by replacing old instances one after the other until all the new instances are rolled out. This deployment model is also called as incremental deployment. This type of deployment follows an approach of creating a new instance and add it to the running instance pool, when that instance is added to the Load balancer without any issues, one of the old running instance is removed from the pool, this adding and removing excercise is continuied until all the instances are replaced with a new version. This type of deployment is good for stateful application redeployment where more time is required to rebalancing the data. One of the cons of this type of deployment is, traffic flow to new instances cannot be controlled 


This deployment strategy provides various additional options like given below

            max batch size: Number of concurrent instances to roll out.
            Max surge: How many instances to add in addition of the current amount.
            Max unavailable: Number of unavailable instances during the rolling update procedure.

The code snippet required to add in deployment yaml to enable this deployment method is as given below

            replicas: 2  
            strategy:
                type: RollingUpdate
                rollingUpdate:
                  maxSurge: 1
                  maxUnavailable: 0

=== Blue/Green Deployment
Blue/Green deployment is a strategy to achieve very minimum application downtime. This strategy costs more than any other deployment strategy because it need double set of resources to achieve the objective. In this strategy, 2 identical environments will be created, only one environment will be updated with latest version of application and when deployment is verified success, associated load balancer switch the traffic from older version resources to new version resources. 

Blue represents the current version of the application, while green represents the new version. 

This deployment strategy work well if the deployment need to roll back because it involved only switching the traffic from old version to new version through the load balancer. 

Kubernetes 'selector' is the key component in this deployment strategy. If the traffic need to routed to a new version, just update the version number in the below code snippet to v2.0 (example) and update the corresponding tag in 'service' and restart the service 

          selector:
            app: my-application
            version: v1.0

=== Canary Deployment
Canary deployment is a method of running multiple versions of same application on the same cluster resource pool.  This model of deployment is useful when multiple versions of an application feature need to tested on random basis or with a fixed set of traffic. 

For the random number of user based testing requirement, multiple version of same application is deployed on same cluster with no restrictions on traffic. For example, we can deploy 2 versions of same applciation as you can see below with 2 instance of one version and 6 instances of other version. Traffic will be random on both these version instances
         
            replicas: 2
            template:
              metadata:
                labels:
                  app: ab-test-all-color-instance #unique identifier labels, key component in A/B testing
                  color: red #unique identifier labels, key component in A/B testing
              spec:
                containers:
                  - name: echocolor
                    image: shamjithantholi/echocolor:v1.0  #Docker Image details
                    ports:
                      - containerPort: 8080
                    
     
            replicas: 6
            template:
              metadata:
                labels:
                  app: ab-test-all-color-instance #unique identifier labels, key component in A/B testing
                  color: green #unique identifier labels, key component in A/B testing
              spec:
                containers:
                  - name: echocolor
                    image: shamjithantholi/echocolor:v2.0  #Docker Image details
                    ports:
                      - containerPort: 8080
                    
Another canary deployment method is to set the weight on traffic using the service mesh or load balancer.  

== Conclusion


