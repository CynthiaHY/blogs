---
layout: post
title: "Improving on Atomic Reference"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/joe-chacko
author_github: https://github.com/joe-chacko
seo-title: TITLE - OpenLiberty.io
seo-description: DESCRIPTION
blog_description: "DESCRIPTION"
open-graph-image: https://openliberty.io/img/twitter_card.jpg
additional_authors:
- name: Neil Richards
  github: https://github.com/ngmr
  image: https://avatars0.githubusercontent.com/ngmr
---
= Improving on AtomicReference
Joe Chacko <https://github.com/joe-chacko>
:imagesdir: /
:url-prefix:
:url-about: /
//Blank line here is necessary before starting the body of the post.

The https://devdocs.io/openjdk/java.base/java/util/concurrent/atomic/atomicreference[`AtomicReference`] and other `Atomic...` classes in the `java.util.concurrent` package allow multiple threads to read and update values safely.
However, `AtomicReference` alone is of limited use in writing thread-safe code.
This article describes a helpful mechanism to provide a more useful thread-safe reference.

== So what's the trouble with using AtomicReference?

Consider the https://devdocs.io/openjdk~15/java.base/java/util/concurrent/atomic/atomicreference#updateAndGet(java.util.function.UnaryOperator)[`updateAndGet()`] method.
This allows many threads to contend to update the value.
For example, one might write something like this:
[source, java]
----
    private AtomicReference<Widget> ref;

    public Widget getWidget() {
        return ref.updateAndGet(value -> value == null ? new Widget() : value);
    }
----
When `getWidget()` is first invoked, it will create a new `Widget`, but subsequent calls will find the existing one.

So far, so good, but beware!
The contract of the `updateAndGet()` method warns us about the update function: --
[quote]
----
"The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads.""
----
In other words, although the update will only happen once, the update function may be called by several threads simultaneously.
This has implications for compute-intensive operations, too.
If creating a new widget is slow or has side-effects, it is unsuitable for this approach.

More generally, if the update processing should only happen once -- e.g. a lazy initialization step -- then this utility alone is not enough.
There needs to be some additional mechanism to allow threads to contend to update the state.
A common usage pattern is as follows: --

* A single thread must win any race to perform a given state update.
* Any other contender threads should wait for the update and retrieve the result.

In fact, that is what we initially assumed `AtomicReference` would do until we hit a concurrent update bug.
Perhaps we can help you avoid (or resolve) a similar issue.

== Creating a more helpful thread-safe reference

How can we implement an update method that takes an updater function and applies it with the characteristics described?
We need a slightly more expressive interface.
Rather than allowing just an update function, we allow a _supplier of_ an update function.
We introduce the semantic that if the supplier returns `null`, it means that no update is required.
Our method signature looks like this:
[source, java]
----
    public boolean update(Function<T, Supplier<T>> updaterSupplier) {
        // ...
    }
----
Also note that we dispensed with the update-and-get approach.
We weren't actually using the return value of `updateAndGet()`.
We want to know whether the update happened, so we return a `boolean` to indicate that.
Implementing an `updateAndGet()` or even `getAndUpdate()` is left as an exercise for the reader.
(It should be easy!)

Our solution involves an additional layer of indirection (doesn't it always?).
First, let us introduce a very simple `Ref` interface that tells us whether it is in transition.
[source, java]
----
    @FunctionalInterface
    private interface Ref<T> extends Supplier<T> {
        default boolean isReady() { return true; }
    }
----
This is marked as a `FunctionalInterface` because we want the option to populate it with a lambda.
(This is not strictly necessary but hints to the compiler to check the interface can be the type of a lambda expression.)
While the update is being applied, we want a special `Ref` that makes other threads wait for the result:
[source, java]
----
    /** A placeholder ref to allow contending threads to wait for an in-flight update. */
    private static class TransitionalRef<T> implements Ref<T> {
        private final CountDownLatch latch = new CountDownLatch(1);
        private final Thread updaterThread = Thread.currentThread();
        public boolean isReady() {
            // It is not valid to try to retrieve the value
            // from the updating thread while it is still updating
            if (Thread.currentThread() == updaterThread)
                throw new IllegalStateException("Attempt to retrieve value during update process");
            try {
                latch.await();
            } catch (InterruptedException ignored) {}
            return false;
        }
        void markAsReady() { latch.countDown(); }
        public T get() { throw new UnsupportedOperationException();  }
    }
----

We hold one of these `Ref` objects inside an `AtomicReference`.
So, where our original code had `AtomicReference<Widget>`, our new code will have `AtomicReference<Ref<Widget>>`.
See the extra layer of indirection?

The code that waits for a transition to complete is very simple:
[source, java]
----
    private Ref<T> getWithWait() {
        for (;;) {
            Ref<T> ref = atomicReference.get();
            if (ref.isReady()) return ref;
        }
    }
----
This is just a loop that continues until another thread updates the atomic reference to one that is not transitional.
Note that the implementation of `isReady()` will actually wait for the in-flight update to complete, so this will usually only loop around once.
The loop caters for successive updates.
For a single (unlucky) thread, this code will loop around many times -- once for each observed transition.

The `get()` method for our utility is trivial:
[source, java]
----
    /** Observe the <em>consistent</em>>, <em>durable</em>> value held by this reference. */
    public T get() { return getWithWait().get(); }
----

The `update()` implementation is more involved:
[source, java]
----
    public boolean update(Function<T, Supplier<T>> updaterSupplier) {
        Ref<T> ref;
        TransitionalRef<T> tranRef;
        Supplier<T> neededUpdate;
        do {
            ref = getWithWait();
            neededUpdate = updaterSupplier.apply(ref.get()); // <1>
            if (null == neededUpdate) return false; // <2>
            tranRef = new TransitionalRef<>();
        } while (false == atomicReference.compareAndSet(ref, tranRef)); // <3>
        try { // <4>
            T newT = neededUpdate.get();
            ref = () -> newT;
            return true;
        } finally { // <5>
            atomicReference.set(ref);
            tranRef.markAsReady();
        }
    }
----
<1> explain the check
<2> explain the meaning of null here
<3> explain the retry loop
<4> explain the update
<5> explain the commit/rollback finally block

Concurrency is hard so I pair program on it.
We experience more contention that way, but we end up with fewer bugs _and_ I have someone else to blame.


You can https://github.com/OpenLiberty/open-liberty/search?q=AcidReference[search for the latest implementation, tests, and usage of this utility in the OpenLiberty source repository].

// // // // // // // //
// LINKS
//
// OpenLiberty.io site links:
// link:/guides/microprofile-rest-client.html[Consuming RESTful Java microservices]
//
// Off-site links:
//link:https://openapi-generator.tech/docs/installation#jar[Download Instructions]
//
// IMAGES
//
// Place images in ./img/blog/
// Use the syntax:
// image::/img/blog/log4j-rhocp-diagrams/current-problem.png[Logging problem diagram,width=70%,align="center"]
// // // // // // // //