---
layout: post
title: "Building on Atomic Reference"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/joe-chacko
author_github: https://github.com/joe-chacko
seo-title: Building on AtomicReference - OpenLiberty.io
seo-description: AtomicReference does not guarantee that an update function gets called exactly once. We describe a helpful, thread-safe mechanism that builds on AtomicReference to provide such a guarantee. This can be used for lazy initialization, clean-up, or any state change processing that is to happen exactly once.
blog_description: "AtomicReference does not guarantee that an update function gets called exactly once. We describe a helpful, thread-safe mechanism that builds on AtomicReference to provide such a guarantee. This can be used for lazy initialization, clean-up, or any state change processing that is to happen exactly once."
open-graph-image: https://openliberty.io/img/twitter_card.jpg
additional_authors:
- name: Neil Richards
  github: https://github.com/ngmr
  image: https://avatars0.githubusercontent.com/ngmr
---
= Building on AtomicReference
Joe Chacko <https://github.com/joe-chacko>
:imagesdir: /
:url-prefix:
:url-about: /
//Blank line here is necessary before starting the body of the post.

The https://devdocs.io/openjdk/java.base/java/util/concurrent/atomic/atomicreference[`AtomicReference`] and other `Atomic...` classes in the `java.util.concurrent` package allow multiple threads to read and update values safely.
However, `AtomicReference` alone is of limited use in writing thread-safe code.
This article describes a helpful mechanism to provide a more useful thread-safe reference.

== To do or not to do, that is the question

Consider the https://devdocs.io/openjdk~15/java.base/java/util/concurrent/atomic/atomicreference#updateAndGet(java.util.function.UnaryOperator)[`updateAndGet()`] method.
This allows many threads to contend to update the value.
For example, one might write something like this:
[source, java]
----
    private AtomicReference<Widget> ref;

    public Widget getWidget() {
        return ref.updateAndGet(value -> value == null ? new Widget() : value);
    }
----
When `getWidget()` is first invoked, it will create a new `Widget`, but subsequent calls will find the existing one.

So far, so good, but beware!
The contract of the `updateAndGet()` method warns us about the update function: --
[quote]
----
"The function should be side-effect-free, since it may be re-applied when attempted updates fail due to contention among threads."
----
In other words, although the update will only happen once, the update function may be called by several threads simultaneously.
This has implications for compute-intensive operations, too.
If creating a new widget is slow or has side-effects, it is unsuitable for this approach.

More generally, if the update processing should only happen once -- e.g. a lazy initialization step -- then this utility alone is not enough.
There needs to be some additional mechanism to allow threads to contend to update the state.
A common usage pattern is as follows: --

* A single thread must win any race to perform a given state update.
* Any other contender threads should wait for the update and retrieve the result.

In fact, that is what we initially assumed `AtomicReference` would do until we hit a concurrent update bug.
Perhaps we can help you avoid (or resolve) a similar issue.

== Though this be madness, yet there is method in't

How can we implement an update method that takes an updater function and applies it with the characteristics described?
We need a slightly more expressive interface.
Rather than allowing just an update function, we allow a _supplier of_ an update function.
We introduce the semantic that if the supplier returns `null`, it means that no update is required.
Our method signature looks like this:
[source, java]
----
    public boolean update(Function<T, Supplier<T>> updaterSupplier) {
        // ...
    }
----
Also note that we dispensed with the update-and-get approach.
We weren't actually using the return value of `updateAndGet()`.
We want to know whether the update happened, so we return a `boolean` to indicate that.
Implementing an `updateAndGet()` or even `getAndUpdate()` is left as an exercise for the reader.
(It should be easy!)

=== By indirections, find directions out
First, let us introduce a very simple `Ref` interface that tells us whether it is in transition.
[source, java]
----
    @FunctionalInterface
    private interface Ref<T> extends Supplier<T> {
        default boolean isReady() { return true; }
    }
----
This is marked as a `FunctionalInterface` because we want the option to populate it with a lambda.
(This is not strictly necessary but hints to the compiler to check the interface can be the type of a lambda expression.)

While the update is being applied, we want a special `Ref` that makes other threads wait for the result:
[source, java]
----
    /** A placeholder ref to allow contending threads to wait for an in-flight update. */
    private static class TransitionalRef<T> implements Ref<T> {
        private final CountDownLatch latch = new CountDownLatch(1);
        private final Thread updaterThread = Thread.currentThread();
        public boolean isReady() {
            // It is not valid to try to retrieve the value
            // from the updating thread while it is still updating
            if (Thread.currentThread() == updaterThread)
                throw new IllegalStateException("Attempt to retrieve value during update process");
            try {
                latch.await();
            } catch (InterruptedException ignored) {}
            return false;
        }
        void markAsReady() { latch.countDown(); }
        public T get() { throw new UnsupportedOperationException();  }
    }
----

We hold one of these `Ref` objects inside an `AtomicReference`.
So, where our original code had `AtomicReference<Widget>`, we will now use an `AtomicReference<Ref<Widget>>`.
See the extra layer of indirection? We are just warming up!

=== And wait upon the judgement

The code that waits for a transition to complete is very simple:
[source, java]
----
    private Ref<T> getWithWait() {
        for (;;) {
            Ref<T> ref = atomicReference.get();
            if (ref.isReady()) return ref;
        }
    }
----
This method loops until the atomic reference is not transitional any more.
It can only be updated by another thread (because this thread is stuck in this loop).
The implementation of `isReady()` waits for the in-flight transition to complete.
Usually, this loop will run just once or twice, but it does allow for successive updates.
For a single (unlucky) thread, this code will loop around many times -- once for each observed transition.

As an aside, you might be more familiar with `while (true)` for indefinite loops. The `for (;;)` style of indefinite loop arguably has less compare operations, though this is unlikely to make any difference with modern compilers. We just like the look of it better; we call it _the spider operator_. &#128375;

The `get()` method is completely trivial -- get the reference, and dereference it:
[source, java]
----
    /** Observe the <em>consistent</em>>, <em>durable</em>> value held by this reference. */
    public T get() { return getWithWait().get(); }
----

=== And what judgement would step from this to this?

The `update()` implementation is more involved.
Only one thread must be permitted to step into the critical section where the update happens.
Any other threads must wait for the transition to complete before they can access the result.
Let's step through the code to see how this is achieved.
Read the annotations below for a description of each step.
[source, java]
----
    public boolean update(Function<T, Supplier<T>> updaterSupplier) {
        Ref<T> ref = getWithWait(); // <1>
        Supplier<T> neededUpdate = updaterSupplier.apply(ref.get()); // <2>
        if (null == neededUpdate) return false; // <3>
        final TransitionalRef<T> tranRef = new TransitionalRef<>(); // <4>

        while (false == atomicReference.compareAndSet(ref, tranRef)) { // <5>
            ref = getWithWait(); <1>
            neededUpdate = updaterSupplier.apply(ref.get()); // <2>
            if (null == neededUpdate) return false; // <3>
        }

        try { // <6>
            T newT = neededUpdate.get(); // <7>
            ref = () -> newT; // <8>
            return true; // <9>
        } finally {
            atomicReference.set(ref); // <10>
            tranRef.markAsReady(); // <11>
        }
    }
----
<1> Get the existing value. Remember this includes waiting for any in-flight update on another thread.
<2> Use the supplier to check whether this value needs updating.
<3> If the supplier returned `null`, it means that no update was necessary.
<4> Now we know an update is needed, create a transitional reference for the current thread.
<5> Try an atomic compare-and-swap of the original `ref` with this thread's transitional one. If it fails keep retrying steps 1, 2, 3, and 5 until no update is needed (on step 2) or the compare-and-swap succeeds (on step 5).
<6> If a thread proceeds to here, it has been tasked with updating the value.
<7> Use the provided updater to compute the new value. Remember this can be slow or costly, or have side-effects. Any successfully computed value will be applied and observable. This is the _raison d'&ecirc;tre_ of `AcidReference`, as `AtomicReference` can provide no such guarantee.
<8> Create a new non-transitional reference. (At last, the lambda we hinted at earlier.)
<9> Flag up to the caller that this update has succeeded.
<10> Inside this finally block, `ref` will either be the new reference that holds the newly computed value, or -- if an exception was thrown -- ref will have the original value. This call to `set()` either _commits_ the new value, or _rolls back_ to the old one.
<11> Although the ref has been replaced, some threads might be waiting in the `isReady()` call on this thread's `TransitionalRef`. This call to `markAsReady()` unblocks those threads and allows them to continue.

=== There are more things in heaven and earth than are dreamt of in our philosophy
Writing this post made us think of some potential improvements to `AcidReference`.
We made several of these as we went along, but we will probably find others.
You can https://github.com/OpenLiberty/open-liberty/search?q=AcidReference[search for the latest implementation, tests, and usage of this utility in the OpenLiberty source repository].

We also noticed (for the first time) a utility that has been in the Java class library since Java 5: `AtomicMarkableReference`.
This provides an additional boolean flag and further atomic operations to make use of it.
It is certainly useful but falls short of the thread update notification provided by `AcidReference`.
