---
layout: post
title: "TITLE"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/reecenana
author_github: https://github.com/reecenana
seo-title: TITLE - makes sure it ends with - OpenLiberty.io
seo-description: DESCRIPTION
blog_description: DESCRIPTION
open-graph-image: https://openliberty.io/img/twitter_card.jpg
---
= TITLE
Reece Nana <https://github.com/reecenana>
:imagesdir: /
:url-prefix:
:url-about: /
//Blank line here is necessary before starting the body of the post.

// // // // // // // //
// In the preceding section:
// Do not insert any blank lines between any of the lines.
// Do not remove or edit the variables on the lines beneath the author name.
//
// "open-graph-image" is set to OL logo. Whenever possible update this to a more appriopriate/specific image (For example if present an image that is being used in the post). However, it
// can be left empty which will set it to the default
//
// Replace TITLE with the blog post title eg: MicroProfile 3.3 is now available on Open Liberty 20.0.0.4
// Replace mbroz2 with your GitHub username eg: lauracowen
// Replace DESCRIPTION with a short summary (~60 words) of the release (a more succinct version of the first paragraph of the post).
// Replace Michal Broz with your name as you'd like it to be displayed, 
// eg: LauraCowen
//
// For every link starting with "https://openliberty.io" in the post make sure to use
// {url-prefix}. e.g- link:{url-prefix}/guides/GUIDENAME[GUIDENAME]:
//
// If adding image into the post add :
// -------------------------
// [.img_border_light]
// image::img/blog/FILE_NAME[IMAGE CAPTION ,width=70%,align="center"]
// -------------------------
// "[.img_border_light]" = This adds a faint grey border around the image to make its edges sharper. Use it around screenshots but not           
// around diagrams. Then double check how it looks.
// There is also a "[.img_border_dark]" class which tends to work best with screenshots that are taken on dark backgrounds.
// Change "FILE_NAME" to the name of the image file. Also make sure to put the image into the right folder which is: img/blog
// change the "IMAGE CAPTION" to a couple words of what the image is
// // // // // // // //

BETA_RELEASE_SUMMARY

// // // // // // // //
// Change the RELEASE_SUMMARY to an introductory paragraph. This sentence is really
// important becuase it is supposed to grab the readers attention.  Make sure to keep the blank lines 
//
// Throughout the doc, replace 22.0.0.10-beta with the version number of Open Liberty, eg: 22.0.0.2-beta
// // // // // // // //

The link:{url-about}[Open Liberty] 22.0.0.10-beta includes the following beta features (along with link:{url-prefix}/docs/latest/reference/feature/feature-overview.html[all GA features]):

* <<java, Java 19 Support>>
* <<xml, XML Binding 4.0>>
* <<bell, BELL SPI Visibility and BELL Properties>>
* <<microprofile, MicroProfile Telemetry 1.0>>
* <<security, Distributed Security Caches>>

// // // // // // // //
// In the preceding section:
// Change SUB_FEATURE_TITLE to the feature that is included in this release and
// change the SUB_TAG_1/2/3 to the heading tags
//
// However if there's only 1 new feature, delete the previous section and change it to the following sentence:
// "The link:{url-about}[Open Liberty] 22.0.0.10-beta includes SUB_FEATURE_TITLE"
// // // // // // // //

// https://github.com/OpenLiberty/open-liberty/issues/22166
[#java]
== Java 19 Support
Java 19 is coming soon, and with it the following features and changes:

* 405: Record Patterns (Preview)
* 422: Linux/RISC-V Port
* 424: Foreign Functions & Memory API (Preview)
* 425: Virtual Threads (Preview)
* 426: Vector API (Fourth Incubator)
* 427: Pattern Matching for switch (Third Preview)
* 428: Structured Concurrency (Incubator)

By taking advantage of trying out the new changes in Java 19 now, you will get more time to review your applications, microservices and runtime environments which means you will be a step ahead when it becomes generally available.

To give this a try, link:https://jdk.java.net/19/[download the early access release of Java 19], download and install the link:https://openliberty.io/downloads/#runtime_betas[22.0.0.10-beta] version of Open Liberty, edit your Liberty server's link:https://openliberty.io/docs/22.0.0.10/reference/config/server-configuration-overview.html#server-env[server.env] file to point JAVA_HOME to your Java 19 installation and start testing!

For more information on Java 19, visit the Java 19 link:https://jdk.java.net/19/release-notes[release notes page], link:https://download.java.net/java/early_access/jdk19/docs/api/[API Javadoc page] or link:https://openliberty.io/docs[download page].
For more information on Open Liberty, please visit our documentation page.

As work is made towards full Java 19 support, there may be functionality that might not be 100% ready yet but is in progress to be complete soon!


// https://github.com/OpenLiberty/open-liberty/issues/22092
[#xml]
== XML Binding 4.0
Jakarta XML Binding 4.0 is an API for automating the mapping between XML documents and Java objects. Support provides the updated XML Binding 4.0 API, its Reference Implementation, and introduces the xmlBinding-4.0 feature to Open Liberty.


The xmlBinding-4.0 feature provides the Jakarta XML Binding 4.0 tools for marshaling and unmarshaling XML to Java: xjc and schemagen. Both command line tools perform identically to the Jakarta EE 9 tooling.


To enable the new Jakarta XML Binding 4.0 feature, add the xmlBinding-4.0 feature to your `server.xml`. Here's an example of what the feature configuration looks like:

[source,xml]
----
    <featureManager>
          <feature>xmlBinding-4.0</feature>
    </featureManager>  
----

For more information see the link:https://jakarta.ee/specifications/xml-binding/[Jakarta XML Binding Specification]

// https://github.com/OpenLiberty/open-liberty/issues/21974
[#bell]
== BELL SPI Visibility and BELL Properties
The link:https://openliberty.io/docs/latest/reference/feature/bells-1.0.html[Basic Extensions using Liberty Libraries (BELL) 1.0] feature enables shared libraries to provide implementations of Liberty API interfaces using Java link:https://docs.oracle.com/javase/9/docs/api/java/util/ServiceLoader.html[ServiceLoader] configuration files.

22.0.0.10-beta introduces two capabilities for BELL services: SPI visibility, and properties configuration and injection.

Previously these capabilities were available only to user feature extensions. User features offer more capabilities than BELL services, but come with a more complex development model. These capabilities afford extension developers greater opportunity to leverage the simplicity of BELL services.

BELL SPI visibility makes feature SPI packages visible only to shared libraries referenced in BELL configurations. The introduction of BELL SPI visibility enables developers to provide implementations of SPI interfaces as BELL services rather than user features, which typically require more time to develop.

BELL properties configuration and injection enables BELL services to receive properties configured in the server.xml file. The introduction of BELL properties allows users to exploit the benefits of the Liberty configuration and obviates the need to configure BELL services with environment variables or JVM system properties.

To enable SPI visibility declare Boolean attribute `spiVisibility=“true”` in your BELL configuration. SPI visibility is disabled by default.

To specify properties add a `<properties/>` element within your BELL configuration and declare one or more `name="value"` attributes. Properties are type `String` and apply to all services provided by the referenced library.

The configuration below enables SPI visibility for services provided by shared library `ServletExtLib` and declares two properties, `servletName` and `servletMapping`.

[source, xml]
----
        <library id=”ServletExtLib">
            <fileset dir="${server.output.dir}/sharedLib" includes="ServletExtLib.jar" />
        </library>

        <bell libraryRef=”ServletExtLib”
              service="javax.servlet.ServletContainerInitializer"
              spiVisibility=”true">
           <properties servletName=“RestSciServlet” servletMapping="/rest/*" />
        </bell>
----

In order to receive properties at runtime, modify your service implementation classes by defining either a public constructor or a public method named `updateBell`, each having a single parameter of type `java.util.Map<String,String>`. The `updateBell` method is intended to support non-destructive updates and must tolerate multiple calls on the same service instance.

The example below defines method `updateBell` within service implementation class `RestSci`.

[source, java]
----
        package my.servlet.extensions;
        ...    
        public class RestSci implements javax.servlet.ServletContainerInitializer {
           public RestSci() {}

           public void updateBell(java.util.Map<String, String> properties) { 
              // Collect properties 
           }
           ...
        }
----
At runtime the server will make SPI packages visible only to a specialized classloader for library `ServletExtLib`. Applications can declare `commonLibRef="ServletExtLib"` in their `<classloader/>` configuration, but they will not see SPI packages. Regarding `<properties/>` the server will inject an unmodifiable map with `key=value` pairs `"servletName"="RestSciServlet"` and `"servletMapping"="/rest/*"` into all services when created during startup and after BELL configuration updates.

The following steps describe how to bring up a BELL service that implements the REST Handler SPI interface `com.ibm.wsspi.rest.handler.RESTHandler`, which was impossible until now.


=== Create the service resource and implementation class files

The resource file is named for the SPI interface and declares the fully-qualified name of the implementation class. The minimal resource file content is shown below. Notice the file also declares an OSGi property required by the RESTHandler interface -- the entry starting with `#` -- that enables the REST Handler framework to register the service as a listener for a specified URL sub-root. In this example the URL sub-root is `/bellEP`.

[source, java]
----
    #com.ibm.wsspi.rest.handler.root=/bellEP
    your.org.rest.example.BellEndpoint
----

And here's a skeletal implementation of SPI interface `com.ibm.wsspi.rest.handler.RESTHandler`. The implementation defines method `updateBell` to receive BELL properties. The `updateBell` method is intended for non-destructive updates and must tolerate multiple calls on the same service instance.

[source, java]
----
    package your.org.rest.example;
    import com.ibm.wsspi.rest.handler.*;
    ...
    public class BellEndpoint implements com.ibm.wsspi.rest.handler.RESTHandler {
        public BellEndpoint() {}
        public void updateBell(java.util.Map<String, String> properties) {...}
        @Override
        public void handleRequest(RESTRequest request, RESTResponse response) {...}
    }
----

Package the files into a JAR file, say `RestEpLib.jar`:

[source, java]
----
    META-INF/services/com.ibm.wsspi.rest.handler.RESTHandler
    your/org/rest/example/BellEndpoint.class
----

=== Configure the server

Add the following features to the `server.xml` file. The `restConnector-2.0` feature enables the REST Handler framework and exports the REST Handler SPI package required by the BELL service. Access to REST endpoints requires secure transport (`transportSecurity-1.0`) and that a user is mapped to the administrator role. 

[source, xml]
----
     <featureManager>
         <feature>bells-1.0</feature>
         <feature>restConnector-2.0</feature>
         <feature>transportSecurity-1.0</feature>
     </featureManager>
----

Now add the shared library and BELL. The following configuration enables SPI visibility for the `RestEpLib` library and declares one property, `hello="WORLD"`. Enable SPI visibility whenever a BELL service implementation requires SPI packages exported by a configured feature(s). Remember to copy file `RestEpLib.jar` to the directory specified in the library's `<fileset/>`.

[source, xml]
----
    <library id=”RestEpLib">
        <fileset dir="${server.output.dir}/sharedLib" includes="RestEpLib.jar" />
    </library>

    <bell libraryRef=”RestEpLib”
            service="com.ibm.wsspi.rest.handler.RESTHandler"
            spiVisibility=”true">
        <properties hello=“WORLD” />
    </bell>
----

Add the keystore for transport security and map a user to the administrator role:

[source, xml]
----
     <keyStore id="defaultKeyStore" password="keystorePassword" />
     <basicRegistry>
         <user name="you" password="yourPassword" />
         <group name="yourGroup" />
     </basicRegistry>
     <administrator-role>
         <user>you</user>
         <group>yourGroup</group>
     </administrator-role>
----

=== Save your changes and start the server

Look for messages CWWKL0059I and CWWKL0050I in server logs indicating the server enabled BELL SPI visiblity and registered the BELL service. The server makes REST Handler SPI packages visible to a unique classloader for library `RestEpLib`. Applications may declare a common library reference to `RestEpLib` (`commonLibRef="RestEpLib"`) in their `<classloader/>` configuration, but they will not see SPI packages.

[source, xml]
----
[...] 00000001 com.ibm.ws.classloading.bells.internal.Bell                  I BETA: BELL SPI Visibility and BELL Properties has been invoked by class com.ibm.ws.classloading.bells.internal.Bell for the first time.
[...] 00000001 com.ibm.ws.classloading.bells.internal.Bell                  I CWWKL0059I: BELL SPI visibility is enabled for the RestEpLib library. The BELL references the RestEpLib library through a unique class loader that can see SPI packages.
[...] 00000001 com.ibm.ws.classloading.bells.internal.Bell                  I CWWKL0050I: The RestEpLib library registered the service that is declared in the wsjar:file:/<your_wlp>/usr/servers/bell_ep_server/sharedLib/RestEpLib!/META-INF/services/com.ibm.wsspi.rest.handler.RESTHandler file, using your.org.rest.example.BellEndpoint implementation class.
----

When the server registers the BELL service with the OSGi framework it triggers the REST Handler framework to register the service as a listener for URL sub-root `/bellEP`. The /bellEP endpoint is now accessible.

You can now make calls to `https://<host>:8020/ibm/api/bellEP`.

The REST handler framework references the BELL service to serve the `/bellEP` endpoint. During the first reference the server creates an instance of class BellEndpoint and injects an unmodifiable map with key/value pair `"hello"/"WORLD"`. The server injects BELL properties at service creation and after BELL configuration updates.

You can find out more about this specific update from the following links:

* link:https://openliberty.io/docs/latest/reference/feature/bells-1.0.html[Open Liberty BELL 1.0 Feature Doc]
* link:https://docs.oracle.com/javase/9/docs/api/java/util/ServiceLoader.html[Java ServiceLoader]
* link:https://openliberty.io/docs/latest/reference/config/bell.html[Open Liberty BELL Server Configuration Doc]

// https://github.com/OpenLiberty/open-liberty/issues/21847
[#microprofile]
== MicroProfile Telemetry 1.0

link:https://opentelemetry.io/[OpenTelemetry] is a set of APIs, SDKs, tooling and integrations that are designed for the creation and management of telemetry data such as traces, metrics, and logs.


This feature adopts OpenTelemetry from CNCF to allow MicroProfile Applications to benefit from OpenTelemetry and enable automatic tracing of Jakarta RESTful Web Services if configured.

[source, xml]
----
<featureManager>
  <feature>mpTelemetry-1.0</feature>
</featureManager>
----

You can view the telemetry data from your application in link:https://www.jaegertracing.io/docs/1.37/monitoring/#traces[Jaeger] and  link:https://zipkin.io/pages/quickstart.htmlp[Zipkin]. To export your traces to one of these exporters, configure the exporter with system properties, e.g. `-Dotel.traces.exporter=jaeger` or environment variables, e.g. `OTEL_TRACES_EXPORTER=jaeger`.  You can also configure the exporter endpoints using `OTEL_EXPORTER_JAEGER_ENDPOINT` and `OTEL_EXPORTER_ZIPKIN_ENDPOINT`.  To specify the name of the service, use `OTEL_SERVICE_NAME`.
   
For more information about MicroProfile Telemetry, see the following links:

* link:https://github.com/eclipse/microprofile-telemetry[microprofile-telemetry]
* link:https://github.com/open-telemetry/opentelemetry-specification/blob/v1.11.0/specification/trace/api.md[opentelemetry-specification]
* link:https://opentelemetry.io[opentelemetry.io]

// https://github.com/OpenLiberty/open-liberty/issues/20209
[#security]
== Distributed Security Caches

   
   - A sentence or two that introduces the update to someone new to the general technology/concept.
   
 > Distributed security cache support has been introduced so that multiple Liberty servers can share caches via a JCache provider.

   - What was the problem before and how does your update make their life better? (Why should they care?)

> Prior to this feature, the authentication (subject) and logged out cookie caches were restricted to be local and in-memory. Multiple servers were unable to benefit from their peers' caches and each server started with a cold cache.
>
> As part of this feature both caches can now both be stored in a distributed JCache. This can improve performance and failure recovery, reduce the load on backend user registries and improve the security posture of the server.
   
   - Briefly explain how to make your update work. Include screenshots, diagrams, and/or code snippets, and provide a `server.xml` snippet.

> NOTE: When using the new distribute caching functionality in this beta release, the feature `distributedSecurityCache-1.0` needs to be included in the list of features in the server.xml file. This beta-only feature that is used to expose the JCache APIs to the 3rd party JCache provider. When the distributed caching functionality is GA'd, this feature will no longer be available.

```
========================================================================
Configuring a Distributed Authentication Cache
========================================================================
```

> Because the creation of a subject might affect performance, Liberty provides an authentication cache to store a subject after an authentication of a user is successful. The authentication cache now can be distributed using a 3rd party JCache provider. To configure the distributed authentication cache, use the following server.xml configuration:

```
    <featureManager>
        <feature>appSecurity-3.0</feature>
        <feature>distributedSecurityCache-1.0</feature>
    </featureManager>

    <!-- 
        The 3rd-party JCache provider library that Liberty will use to manage and connect to the cache.
     -->
    <library id="JCacheProviderLib">
        <fileset dir="${shared.resource.dir}" includes="jcacheprovider.jar" />
    </library>

    <!-- 
        Configure the JCache cache instance.
     -->
    <cache id="AuthCache" name="AuthCache">
        <cacheManager uri="uri://someuri">
            <properties prop1="value1" prop2="value2" />

            <cachingProvider libraryRef="JCacheProviderLib" />
        </cacheManager>
    </cache>

    <!-- 
        Configure the authentication cache.
     -->
    <authCache cacheRef="AuthCache" />
```

> If your Liberty environment injects custom principals or credentials into your subject (for instance in a custom LoginModule or Trust Association Interceptor (TAI)), in order to store them in the distributed authentication cache, they will need to be Serializable. Additionally, it is important that the shared library that contains those classes is made available to the caching provider and any other configurations that need access to those classes. If the same shared library is not used for each, ClassCastExceptions could be encountered when working with the classes retrieved from the distributed cache.

    <featureManager>
        <feature>appSecurity-3.0</feature>
        <feature>distributedSecurityCache-1.0</feature>
    </featureManager>

    <!-- 
        The 3rd-party JCache provider library that Liberty will use to manage and connect to the cache.
     -->
    <library id="JCacheProviderLib">
        <fileset dir="${shared.resource.dir}" includes="jcacheprovider.jar" />
    </library>

    <!-- 
        This shared library contains any custom credentials and/or principals that
        are stored in the subject.
     -->
    <library id="CustomLib">
        <fileset dir="${shared.resource.dir}" includes="customlibrary.jar" />
    </library>

    <!-- 
        Take notice that the 'libraryRef' attribute has both library references.
     -->
    <cache ... >
        <cacheManager ... >
            <cachingProvider libraryRef="JCacheProviderLib,CustomLib" />
        </cacheManager>
    </cache>

    <!--
        Some sample JAAS custom login module configuration. The custom login module
        in this example would inject custom credentials or principals into the subject.

        Note that the 'libraryRef' in the 'jaasLoginModule' needs to be set to the same
        library referenced from the caching provider.
     -->
    <jaasLoginContextEntry id="system.WEB_INBOUND"
        name="system.WEB_INBOUND"
        loginModuleRef="custom, hashtable, userNameAndPassword, certificate, token" />

    <jaasLoginModule id="custom"
        className="org.acme.CustomLoginModule"
        controlFlag="REQUIRED" libraryRef="CustomLib" />

    <!-- 
        Any applications that will be accessing classes from the Subject also need
        to use the same library reference.
     -->
    <application ...>
        <classloader commonLibraryRef="CustomLib" />
    </application>


>A few points to consider when configuring a JCache cache for use with the authentication cache.
>- the distributed authentication cache is comprised of keys and values of type Object
>- to match the behavior of the local authentication cache, set a least recently used eviction (LRU) policy with a maximum entry count of 25000 and an entry TTL of 600 seconds. Note that with distributed caches, partitioning of the cache can lead to an actual capacity below the configured value. 
>- if your JCache provider supports it, configure a client-side cache to reduce transactions to the distributed cache. If the client-side cache supports storing the entries as deserialized objects, this can further improve performance.
>- support in the beta is currently limited to LTPA and JWT. Single sign-on methods such as SPNEGO, Oauth, OIDC and SAML (etc) are not yet supported
>- Subjects in the distributed cache should be treated as you would treat other security-sensitive information, such as usernames and passwords. Configure your JCache provider to secure the data while it is in motion and at rest. This should include encryption and access control.

```
========================================================================
Configuring a Distributed Logged-Out Cookie Cache
========================================================================
```
> The logged-out cookie cache stores LTPA and JWT cookies that have been logged-out. The logged-out cookie cache can now be distributed using a 3rd party JCache provider ensuring that logged out cookies are enforced across multiple servers. To configure the distributed logged-out cookie cache, use the following server.xml configuration:

```
    <featureManager>
        <feature>appSecurity-3.0</feature>
        <feature>distributedSecurityCache-1.0</feature>
    </featureManager>

    <!-- 
        The 3rd-party JCache provider library that Liberty will use to manage and connect to the cache.
     -->
    <library id="JCacheProviderLib">
        <fileset dir="${shared.resource.dir}" includes="jcacheprovider.jar" />
    </library>

    <!-- 
        Configure the JCache instances.
     -->
    <cache id="LoggedOutCookieCache" name="LoggedOutCookieCache">
        <cacheManager uri="uri://someuri">
            <properties prop1="value1" prop2="value2" />

            <cachingProvider libraryRef="JCacheProviderLib" />
        </cacheManager>
    </cache>

    <!-- 
        Configure the authentication cache to use the JCache. 
     -->
    <webAppSecurity loggedoutCookieCacheRef="LoggedOutCookieCache" />
```

>A few points to consider when configuring a JCache cache for use with the logged-out cookie cache.
>- the distributed logged-out cookie cache is comprised of keys and values of type Object
>- to match the behavior of the local logged-out cookie cache, configure the cache with a maximum entry count of 10000 and an entry TTL of unlimited. Note that with distributed caches, partitioning of the cache can lead to an actual capacity below the configured value. The cache capacity should be large enough that no cookies that have not expired will be evicted due to new logged out cookies being inserted into the cache.
>- if your JCache provider supports it, configure a client-side cache to reduce transactions to the distributed cache. If the client-side cache supports storing the entries as deserialized objects, this can further improve performance.

```
========================================================================
Configuring a Session Cache with the new Distributed Cache Configuration
========================================================================
```
> The sessionCache-1.0 feature has been updated to allow use of the new distributed cache configuration elements to allow common configuration across all features that use JCache. This eliminates the need to configure JCache separately for the session cache.

```
    <featureManager>
        <feature>distributedSecurityCache-1.0</feature>
        <feature>sessionCache-1.0</feature>
    </featureManager>

    <!-- 
        The 3rd-party JCache provider library that Liberty will use to manage and connect to the cache.
     -->
    <library id="JCacheProviderLib">
        <fileset dir="${shared.resource.dir}" includes="jcacheprovider.jar" />
    </library>

    <!-- 
        Configure the JCache cache manager.
     -->
    <cacheManager id="CacheManager" uri="uri://someuri">
        <properties prop1="value1" prop2="value2" />

        <cachingProvider libraryRef="JCacheProviderLib" />
    </cacheManager>

    <!--
        Configure the HTTP session cache.
     -->
    <httpSessionCache cacheManagerRef="CacheManager" ... />
```

```
========================================================================
Configuring Multiple Caches
========================================================================
```
> When configuring multiple distributed caches, instead of nesting the cacheManager configuration element within the cache element, the cache element needs to refer to the cache manager via the cacheRef attribute.

```
    <featureManager>
        <feature>appSecurity-3.0</feature>
        <feature>distributedSecurityCache-1.0</feature>
        <feature>sessionCache-1.0</feature>
    </featureManager>

    <!-- 
        The 3rd-party JCache provider library that Liberty will use to manage and connect to the cache.
     -->
    <library id="JCacheProviderLib">
        <fileset dir="${shared.resource.dir}" includes="jcacheprovider.jar" />
    </library>

    <!-- 
        Configure the JCache cache manager.
     -->
    <cacheManager id="CacheManager" uri="uri://someuri">
        <properties prop1="value1" prop2="value2" />

        <cachingProvider libraryRef="JCacheProviderLib" />
    </cacheManager>

    <!-- 
        Configure the JCache cache instances.
     -->
    <cache id="AuthCache" name="AuthCache" cacheManagerRef="CacheManager" />
    <cache id="LoggedOutCookieCache" name="LoggedOutCookieCache" cacheManagerRef="CacheManager" />

    <!-- 
        Configured the authentication cache, logged-out cookie cache and HTTP session cache.
     -->
    <authCache cacheRef="AuthCache" />
    <webAppSecurity loggedoutCookieCacheRef="LoggedOutCookieCache" ... />
    <httpSessionCache cacheManagerRef="CacheManager" ... />
```
   
   - Where can they find out more about this specific update (eg Open Liberty docs, Javadoc) and/or the wider technology?

- https://www.ibm.com/docs/en/was-liberty/base?topic=liberty-configuring-authentication-cache-in
- https://www.ibm.com/docs/en/was-liberty/base?topic=manually-configuring-liberty-session-persistence-jcache




To enable the new beta features in your app, add them to your `server.xml`:

[source, xml]
----

----

[#run]
=== Try it now 

To try out these features, just update your build tools to pull the Open Liberty All Beta Features package instead of the main release. The beta works with Java SE 19, Java SE 18, Java SE 17, Java SE 11, and Java SE 8, however, the Jakarta EE 10 features are only compatible with Java SE 11 and later.

If you're using link:{url-prefix}/guides/maven-intro.html[Maven], here are the coordinates:

[source,xml]
----
<dependency>
  <groupId>io.openliberty.beta</groupId>
  <artifactId>openliberty-runtime</artifactId>
  <version>22.0.0.10-beta</version>
  <type>pom</type>
</dependency>
----

Or for link:{url-prefix}/guides/gradle-intro.html[Gradle]:

[source,gradle]
----
dependencies {
    libertyRuntime group: 'io.openliberty.beta', name: 'openliberty-runtime', version: '[22.0.0.10-beta,)'
}
----

Or take a look at our link:{url-prefix}/downloads/#runtime_betas[Downloads page].

[#feedback]
== We welcome your feedback

Let us know what you think on link:https://groups.io/g/openliberty[our mailing list]. If you hit a problem, link:https://stackoverflow.com/questions/tagged/open-liberty[post a question on StackOverflow]. If you hit a bug, link:https://github.com/OpenLiberty/open-liberty/issues[please raise an issue].


