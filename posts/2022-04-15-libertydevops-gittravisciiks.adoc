---
layout: post
title: "Continuous integration and delivery (CI/CD) of Open Liberty applications to OpenShift using Travis CI"
categories: blog
author_picture: https://avatars3.githubusercontent.com/shamjithantholi
author_github: https://github.com/shamjithantholi
seo-title: TITLE - OpenLiberty.io
seo-description: DESCRIPTION
blog_description: "A high level explanation about how to build a devops pipeline with Travis CI. "
open-graph-image: https://openliberty.io/img/twitter_card.jpg
---
= Continuous integration and delivery (CI/CD) of Open Liberty applications to OpenShift using Travis CI
Shamjith Antholi https://github.com/shamjithantholi
:imagesdir: /
:url-prefix:
:url-about: /

[#Intro]
== DevOps, CI/CD, Travis CI, OpenShift & OpenLiberty
DevOps is a culture or a process, which enables the integration of the software development (dev) and IT operations (ops). It can facilitate the setup of deployment pipeline and helps to improve the speed of software delivery. Automation of the entire build, test, and deployment of the software applications can be achieved through DevOps process. There are tons of efficient applications and process methodologies available in the market that can be readily integrated to the DevOps pipeline, which can help to achieve the wanted results.

CI/CD are acronym’s for continuous integration, and continuous delivery or deployment used in DevOps. Continuous integration is a process where developers frequently merge code changes into a source code repository, which automatically start code build, security scan, and test execution and deployment. Automation of this process enables organizations to release on a more frequent basis without compromising on quality. There are various tools available to automate the CI/CD process. In this blog post we'll discuss how you can use Travis CI to automate the CI/CD process for building, testing, and deploying your Open Liberty Java applications 

Travis CI is a contienous integration service use to build and test the code. Travis CI works with various Git flavors ( eg: GitHub, Bitbucket).

link:https://www.redhat.com/en/technologies/cloud-computing/openshift[OpenShift] is a containerization platform from RedHat. Contiainer orchastration in OpenShift are managed by Kubernetes and its build around linux containers.

Open Liberty is a lightweight Java runtime for building cloud-native applications and microservices. In this blog, it details how you can use Jenkins in CI/CD pipeline for Java based Openliberty application build/test/deployment Openliberty link:https://openliberty.io[OpenLiberty] .

The following diagram shows a simple architecture for a pipeline that builds and deploys an Open Liberty application in a single Kubernetes environment. When a code change is detected by Travis CI, Travis builds the code, runs security and static analysis scans, and runs unit tests against the built code. Travis CI then generates a Docker image of the application with its Open Liberty server and saves the image to a Docker repository, Travis then trigger the deployment using CLI commands and deploy the Docker image to OpenShift.

image::/img/blog/liberty-devops-generic-architecture-travis-ocp.png[Liberty devops generic architecture diagram ,width=70%,align="center"]

Basic understanding of git, Docker and containerization concepts are a prerequisite for this blog.

== Setting up Travis CI and OpenShift for CI/CD of Open Liberty applications ==

Provision *Travis CI* from link:https://www.travis-ci.com/?_gl=1%2A1tiil9q%2A_ga%2AMTIwMjg2NTQ2NS4xNjUwNTUwODU5%2A_ga_XRYGSZFQ0P%2AMTY1MDkwOTQwMC40LjAuMTY1MDkwOTQwOC41Mg..[Travis CI] and integrate your GitHub repository with it (when your personal profile or repository is integrated with travis CI, presense of a *.travis.yml* file in the repository will be enough for syncing that repository with travis CI). 

     --> Go to "https://app.travis-ci.com/signin" and Sign up with GitHub.
     --> Accept the Authorization of Travis CI. You’ll be redirected to GitHub.

image::/img/blog/travisci-homepage.png[Travis CI - Github integration ,width=50%,align="center"]

image::/img/blog/travis-integrated-gitrepo.png[Travis CI - Github integration ,width=50%,align="center"]

     --> Activate the required project as shown in the above screenshot

Provision the OpenShift cluster on IBM cloud (https://cloud.ibm.com), generate OpenShift token for CLI connectivity, verify the basic k8s cluster login commands (please note: For working with the steps explained in this blog, you can use any other kubernetes service of your choice ).     

The next step is to complete the openshift platform setup to make it ready for application deployment. After installing/provisioning a managed OpenShift, login to it using username and password and get the authentication token which is going to be used in Travis CI for connectivity

Create a new project/namespace. Create OpenShift secrets to checkout the code from GitHub to OpenShift (upload the public to github ) and another one for accessing dockerhub repository from OpenShift
     
        oc create secret generic ssh-git \
              --from-file=ssh-privatekey=/Users/<username>/.ssh/id_rsa \
              --type=kubernetes.io/ssh-auth   

        oc create secret docker-registry regcred \
            --docker-server=https://index.docker.io/v1/ \
            --docker-username= <username> \
            --docker-password=<password> \
            --docker-email=<email-id>

Create a new application on OpenShift

        oc new-app git@github.ibm.com:shamjith-antholi/traviscidemo.git --source-secret=<ssh-git>

This command will create the build, deployment and service on OpenShift automatically. Verify that if the deployment is done successfully by login to OpenShift UI. Create a route on OpenShift and verify if the endpoints are reachable.

When deployment is successfull to local image stream, edit the OpenShift BuildConfig and DeploymentConfig to use the DockerHub repository for storing and pulling images.

BuildConfig YAML view
image::/img/blog/buildconfig-yaml-view.png[OpenShift - BuildConfig YAML view ,width=50%,align="center"]

DeploymentConfig UI view
image::/img/blog/deployment-config-ui-view.png[OpenShift - DeploymentConfig UI view ,width=50%,align="center"]

== Automating application deployment on OpenShift using Travis CI

As explained earlier, *.travis.yml* file must be available on the base path of the GitHub repository. An example view of Github repository base path is given below

      ------ Git repo base path screenshot ------------

Travis CI provides wide variety of configuration options, but i will be providing a simple workable confirguration sample code which is good enough to automate 



== Building the Liberty Java code, packaging and generating Docker image

Below given sample pipeline code can perform the code build, packaging and generating docker image and pushing the same to remote docker hub. You can use it by modifying the parameter section (<>)

 pipeline {
     agent any
     stages {
       stage('Build') {
           steps {
                checkout([$class: 'GitSCM', branches: [[name: '*/main']], extensions: [], userRemoteConfigs: [[credentialsId: ‘<git token>, url: 'https://github.com/liberty/app.git']]])

                    sh '''
                            mvn -U package
                            docker login <remote-docker-image-repository-url> -u "${USERNAME}" -p “${PASSWORD}”
            docker tag liberty-$<code identifier>:$<docker image version> <remote-docker-image-repository-url>/<docker-repo-name>/liberty-$<code identifier>:$<docker image version>
            docker push <remote-docker-image-repository-url>/<docker-repo-name>/liberty-$<code identifier>:$<docker image version>

                    '''   
                   }}}}


Following are the parameter used in this example code

* git token: Personal access token generated from github.
* remote-docker-image-repository-url : Docker hub repository url.
* USERNAME/PASSWWORD: user name and password to connect to docker registry.

image::/img/blog/jenkins-cred-binding-and-corresponding-param.png[Pipeline credential binding and corresponding param,width=30%,align="center"]

* code identifier: This is optional, a unique docker image identifier
* docker image version: docker image version number, a unique identifier   

*Security scan* Security scan can be done along with maven build command (CLI commands way of application scanning) or can do it in a separate pipeline stage. 

For static code analysis, we can use SonarQube community edition. Install sonarqube server by either using file startup type from cli downloading the package in link:https://www.sonarqube.org/success-download-community-edition/[SonarQube server install package] or use docker way as explained in link:https://docs.sonarqube.org/latest/setup/get-started-2-minutes/[Sonarqube server install steps]. SonarQube jenkins client setup details are given in this page link:https://docs.sonarqube.org/latest/analysis/scan/sonarscanner-for-jenkins/[SonarQube client for jenkins]. 

For Docker image scan, you can use link:https://hub.docker.com/r/aquasec/trivy/[Docker image scan with trivy]. This scan will provide the vulnerability details of open source jars used in the application.Sample commands are given below

       sh '''
             docker login -u $docker_login -p $docker_password
             docker build -t $docker_login/sampleapp:v1.0 .
             docker push $docker_login/sampleapp:v1.0 
             docker run aquasec/trivy image $docker_login/sampleapp:v1.0
       '''



== Deployment (CLI) 

For simplicity, I will use the command line (CLI) option to configure Jenkins to deploy a Liberty application to Kubernetes. You could use one of many tools though, such as Helm, Travis CI, Circle CI, etc.

Create a new stage in the pipeline code and write all the required commands between the shell option (sample commands give below)
                           
                           sh '''
                              ibmcloud ks cluster config --cluster $CLUSTER-ID
                              kubectl config current-context
                              kubectl create -f deploy/deployment.yaml #( simple k8s deployment command )
                              kubectl create -f deploy/service.yaml #( simple k8s deployment command )
                              kubectl create -f deploy/route.yaml #( simple k8s deployment command )
                              '''

Maintain all the kubernetes configuration files in the same code repository (under a folder called "deploy") 

When Jenkins has checked out the Liberty Java application code for the code build, all the Kubernetes configuration files are also downloaded to the Jenkins workspace so that Jenkins can run the IBM Cloud and Kubernetes commands to connect to the Kubernetes cluster and deploy the application.

 -> Set the kubernetes context as per the requirement, for example, if we need to deploy into development cluster, 
 then the context should be set to development cluster, for deployment into QA environment, 
 set it into QA context ( this context setting is depending on the design of the cluster)

All the other required application deployment commands are available in this kubernetes command page which is very straightforward
link:https://kubernetes.io/docs/reference/kubectl/cheatsheet/[Kubernetes sample commands] 

== QA testing options
Apart from running JUnit test cases along with the code build phase, Jenkins can trigger functional and integration QA test cases automatically after deploying the Liberty application.

Configure the test cases on jenkins job and test it manually. Create an "Authentication Token" in "Trigger builds remotely" section under "Build Triggers". Trigger this test case from docker "entrypoint" file using remote rest api call using this authentication token as the identifier

Eg: curl -I -u <auth-token> https://<jenkins-host>/job/<job-name>/build?token=<authentication-token>
Note: Auth token can be generated from postman

== Kubernetes monitoring tools

Kubernetes provides commands to check the application/cluster logs and memory/cpu usage through the commands like 

    -> kubectl logs ..
    -> cat /sys/fs/cgroup/cpu/cpuacct.usage (after connecting to k8s pod)
    -> cat /sys/fs/cgroup/memory/memory.usage_in_bytes (after connecting to k8s pod)

For persistence of logs and usage stats, there are sevaral applications available in the market which can be integrated with kubernetes, details about some of those apps are given below

These tools are deployed in kubernetes cluster itself where the application is running and exposed using route and access the gathered details from UI.

    -> https://grafana.com/oss/loki/
    -> https://medium.com/nerd-for-tech/logging-at-scale-in-kubernetes-using-grafana-loki-3bb2eb0c0872
    -> https://prometheus.io
    -> https://k21academy.com/docker-kubernetes/prometheus-grafana-monitoring/



== Conclusion
There are many ways in which you can configure your DevOps pipeline. This blog post is a quick introduction to how you can use Jenkins to set up a simple CI/CD pipeline to build and deploy your Liberty Java applications.
