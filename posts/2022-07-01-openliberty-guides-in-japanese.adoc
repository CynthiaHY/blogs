---
layout: post
title: "ABC"
# Do NOT change the categories section
categories: blog
author_picture: https://avatars3.githubusercontent.com/jdmcclur
author_github: https://github.com/jdmcclur
seo-title: ABC - OpenLiberty.io
seo-description: Details of the many changes made in Open Liberty over the last few releases (22.0.0.2 to 22.0.0.6) to double MicroProfile JWT processing throughput.
blog_description: "Details of the many changes made in Open Liberty over the last few releases (22.0.0.2 to 22.0.0.6) to double MicroProfile JWT processing throughput."
open-graph-image: https://openliberty.io/img/twitter_card.jpg
---
= JakartaEEとマイクロプロファイルを使ってクラウドネイティブのJavaアプリを開発しましょう
Hiroko Takamiya <https://github.com/una-tapa> 
Takakiyo Tanaka <https://github.com/takakiyo>

:imagesdir: /
:url-prefix:
:url-about: /
//Blank line here is necessary before starting the body of the post.

OpenLibertyのガイドは、マイクロサービスを作成してコンテナ化し、それをKubernetesにデプロイする方法を学ぶのに最適のチュートリアルです。

各ガイドは、トピックごとに、15分から1時間の長さのチートリアルに分かれています。ユーザーの興味やスケジュールに合わせて、どこからでも始めることができます。

開発は、Webブラウザ上のエディタで試すことができ、クラウドネイティブ・アプリケーションのデプロイの仕方は、無料でIBMクラウド上で練習いただけます。

本記事では、OpenLibertyの英語版の開発ガイドを、Chromeブラウザに備え付けの翻訳機能を使って、日本語表示にしてご紹介します。

[.img_border_light]
image::/img/blog/mpjwt-prim-chart-1.png[MicroProfile JWT Performance Chart 1,width=70%,align="center"]

== OpenLibertyのガイドを日本語表示にします

Open Liberty は、モジュラー機能を使用して構築された、軽量のオープン・ソース Java™ ランタイムです。 Libertyは、下記のアプリケーション・フレームワークをサポートします。

* *MicroProfile* マイクロサービスの作成を加速して簡単にするための新しい標準と API を定義するオープン・ソース・プロジェクトです。
* *Jakarta EE ならびに Java™ EE*  JNDI や JAX-RS など、個別の仕様の機能を含みます。
* *Spring Framework と Spring Boot*  Spring Boot の大きな .jar からコンパクトなコンテナーを作成するためのメカニズムを含みます。

OpenLiberty上でのアプリケーション開発のチュートリアルは、https://openliberty.io/guides/ にあります。下記のChoromeブラウザの設定をしていただくことによって、ほぼ日本語でご利用いただけます。やや翻訳がわかりづらい点は、英語表示に戻して見ていただくことにより、英語の勉強にもなります。

（ここにChromeの設定をいれる）

== Performance Analysis

So, how did we double throughput performance? We made many changes, some big and some small. The first thing we noticed in a sampling profile was a lot of time spent (8.53%) doing a `toString` on the Subject. The following example shows the simplified output of our profiling tools.

[source]
----
8.53 com/ibm/ws/webcontainer/security/WebAppSecurityCollaboratorImpl$4.run()Ljava/lang/String;
  8.53 javax/security/auth/Subject.toString()Ljava/lang/String;
----

When we reviewed the code, we discovered the `toString()` is needed only when audit is enabled, which is not the normal use case. 

https://github.com/jhanders34[Jared Anderson] fixed this with the following Pull Request (PR): https://github.com/OpenLiberty/open-liberty/pull/20334

This change improved throughput 12.5% in 22.0.0.4.
[.img_border_light]
image::img/blog/mpjwt-prim-chart-2.png[MicroProfile JWT Performance Chart 2 ,width=70%,align="center"]

Next, we noticed we were spending a lot of time parsing the JSON of the JWT (7.42%), and parsing the same JSON string multiple times. 

[source]
----
1.51 org/jose4j/jwt/JwtClaims.<init>(Ljava/lang/String;Lorg/jose4j/jwt/consumer/JwtContext;)
1.64 com/ibm/ws/security/mp/jwt/impl/utils/ClaimsUtils.parsePayloadAndCreateClaims(Ljava/lang/String;)
1.93 org/jose4j/jwx/Headers.setEncodedHeader(Ljava/lang/String;)
2.34 com/ibm/ws/security/common/jwk/utils/JsonUtils.claimsFromJsonObject(Ljava/lang/String;)
  7.42 org/jose4j/json/JsonUtil.parseJson(Ljava/lang/String;)Ljava/util/Map;
 
----

Jared made this more efficient, and changed a few other related areas with the following PRs: +
https://github.com/OpenLiberty/open-liberty/pull/20700 +
https://github.com/OpenLiberty/open-liberty/pull/20723 +
https://github.com/OpenLiberty/open-liberty/pull/20963 

We also noticed a few areas where we were compiling regular expressions on every request when it was not needed.
[source]
----
0.05 java/lang/String.split(Ljava/lang/String;I)[Ljava/lang/String;
0.21 com/ibm/ws/security/AccessIdUtil.getUniqueId(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
0.33 java/util/regex/Pattern.matches(Ljava/lang/String;Ljava/lang/CharSequence;)Z
  0.58 java/util/regex/Pattern.compile(Ljava/lang/String;)Ljava/util/regex/Pattern;
----

And found another spot where we were using a Stream API, instead of a more efficient `for` loop.
[source]
----
2.63 com/ibm/ws/security/authorization/util/RoleMethodAuthUtil.parseMethodSecurity(Ljava/lang/reflect/Method;Ljava/security/Principal;Ljava/util/function/Predicate;)
  2.63  java/util/stream/ReferencePipeline.anyMatch(Ljava/util/function/Predicate;)Z
----

I fixed these issues with the following PRs: +
https://github.com/OpenLiberty/open-liberty/pull/20753 +
https://github.com/OpenLiberty/open-liberty/pull/20739 

With these changes, Open Liberty was now 32% faster in 22.0.0.5 than 22.0.0.2.

[.img_border_light]
image::img/blog/mpjwt-prim-chart-3.png[MicroProfile JWT Performance Chart 3 ,width=70%,align="center"]

Finally, the biggest change occurred when we discovered that our JWT Cache could perform much better. We were verifying the signature of the JWT on every request, even if it had already been processed before. 

[source]
----
32.27 com/ibm/ws/security/jwt/internal/ConsumerUtil.getSigningKeyAndParseJwtWithValidation(Ljava/lang/String;Lcom/ibm/ws/security/jwt/config/JwtConsumerConfig;Lorg/jose4j/jwt/consumer/JwtContext;)
  32.27 com/ibm/ws/security/jwt/internal/ConsumerUtil.parseJwtWithValidation(Ljava/lang/String;Lorg/jose4j/jwt/consumer/JwtContext;Lcom/ibm/ws/security/jwt/config/JwtConsumerConfig;Ljava/security/Key;)
----

https://github.com/ayoho[Adam Yoho] was able to improve this with: 
https://github.com/OpenLiberty/open-liberty/pull/20733 

Jared also made an additional change to improve the efficiency of regular expressions: https://github.com/OpenLiberty/open-liberty/pull/20922

With these final two changes, throughput is now 97.8% better than in 22.0.0.2!

[.img_border_light]
image::img/blog/mpjwt-prim-chart-4.png[MicroProfile JWT Performance Chart 4 ,width=70%,align="center"]

== More complex application

These results are with a very simple primitive, which does not resemble a real-world application. How much does throughput improve in a more normal microservices application? With link:https://github.com/blueperf/acmeair-mainservice-java[AcmeAirMS], which has two services that consume JWTs (booking and customer), performance improved 17.5% - still impressive!

[.img_border_light]
image::img/blog/mpjwt-acmeairms-chart.png[MicroProfile JWT Performance Chart 5 ,width=70%,align="center"]

== まとめ

In summary, we made many changes over the last few releases to improve the throughput performance of consuming MicroProfile JWTs by almost double. This blog post showed results when using a MicroProfile 5.0 application. We see similar improvements in older versions of MicroProfile since the code that was changed is common to the other versions. Cloud-native performance continues to be a key priority and focus area for us.

