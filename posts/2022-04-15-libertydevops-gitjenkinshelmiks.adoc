---
layout: post
title: "Continuous integration and delivery (CI/CD) of cloud-native Java applications using Jenkins"
categories: blog
author_picture: https://avatars3.githubusercontent.com/shamjithantholi
author_github: https://github.com/shamjithantholi
seo-title: Continuous integration and delivery (CI/CD) of cloud-native Java applications using Jenkins - OpenLiberty.io
seo-description: DESCRIPTION
blog_description: How to build a DevOps pipeline for a cloud-native Java application with Jenkins as the core controller component.
open-graph-image: https://openliberty.io/img/blog/liberty-devops-generic-architecture-2.png
---
= Continuous integration and delivery (CI/CD) of cloud-native Java applications using Jenkins
Shamjith Antholi <https://github.com/shamjithantholi>
:imagesdir: /
:url-prefix:
:url-about: /

[#Intro]

Continuous integration and continuous deployment (CI/CD) is a process in which developers frequently merge code changes into a source code repository, which then automatically starts a code build, security scanning, and test running, and deployment of the application. Automation of this process, through adopting a DevOps culture, tools, and processes, enables organizations to release on a more frequent basis without compromising on quality. There are various tools available to automate the CI/CD process that can be readily integrated into a DevOps deployment pipeline. In this blog post we'll discuss how you can use Jenkins to automate the CI/CD process for building, testing, and deploying your cloud-native Java applications running on link:https://openliberty.io[OpenLiberty].

Jenkins is a popular open source automation server that has hundreds of plugins to help integrate it into your existing DevOps pipeline. For example, Jenkins can pull code changes from a git repository, build the code using Maven, then run Junit tests against the built code, and deploy the application into Kubernetes. You can install Jenkins on any physical or virtual servers, or it can be running as a container on Kubernetes itself.

The following diagram shows a simple architecture for a pipeline that builds and deploys a Jakarta EE & MicroProfile application in a single Kubernetes environment. When a code change is detected by Jenkins, Jenkins builds the code, runs security and static analysis scans, and runs unit tests against the built code. Jenkins then generates a Docker image of the application with its Open Liberty server and saves the image to a Docker repository, Jenkins then triggers the deployment using CLI commands and deploys the Docker image to Kubernetes.

image::/img/blog/liberty-devops-generic-architecture-2.png[Liberty DevOps architecture diagram ,width=70%,align="center"]

In this blog post, I will assume that you have a basic understanding of git, Docker, Kubernetes. I will also assume that the Jakarta EE & MicroProfile application code is stored in link:https://github.com/[Github]. I will use link:https://hub.docker.com/[DockerHub] to store the containerized application (correction: Docker images)and I will deploy the containerized application to link:https://cloud.ibm.com/kubernetes/catalog/create[IBM Cloud Kubernetes Service].

== Installing and configuring Jenkins to set up CI/CD of a cloud-native Java application

Install link:https://www.jenkins.io/doc/book/installing/[Jenkins] with the following plugins on the base image of your Jenkins container image, or on the Jenkins master.

* Maven, to build java code
* Pipeline, for creating Jenkins pipeline jobs
* Multibranch Scan Webhook Trigger, to create Jenkins pipeline type job which pull all branches of code from Git to Jenkins
* Docker, to build and push container images
* Kubernetes, to use k8s template

Jenkins builds the Liberty Java code using Jenkins pipeline scripts. The script can run directly on your Jenkins installation (known as Jenkins master) but, if the application is big, you need to use a Jenkins agent. For more information about about setting up Jenkins agents, see link:https://www.jenkins.io/doc/book/using/using-agents/[Using Jenkins agents] and link:[https://www.jenkins.io/doc/book/pipeline/syntax/Pipeline Syntax].

== Writing Jenkins pipeline scripts

It is good practice to adhere to the concept of infrastructure as a code (IaaC) when writing DevOps pipelines. Writing Jenkins jobs as pipeline scripts is a good example of IaaC.

You can write link:https://www.jenkins.io/doc/book/pipeline/syntax/[Jenkins pipeline code] in one of the following ways:

* Pipeline code written directly in the link:https://www.jenkins.io/doc/book/pipeline/getting-started/[Jenkins UI] and stored in the Jenkins master. This is a useful way to get started. You would need to take a backup of the Jenkins instance to store the pipeline code because it is part of the Jenkins installation. 

image::/img/blog/pipeline-code-on-jenkins.png[Pipeline code directly on Jenkins ,width=70%,align="center"]

* In a Jenkinsfile (a plain text file) in Git and mapping it to Jenkins. This is better for ensuring that your configuration is always under version control. If you have specific build and deployment configurations for separate environments, such as dev, staging, and production, you create a separate Jenkinsfile for each environment and store it in that environment-specific git repository branches. You can use either the "Pipeline" or "Multibranch pipeline" type of job in this case.

image::/img/blog/pipeline-code-on-git.png[Pipeline code stored in a Jenkinsfile on git ,width=50%,align="center"]

== Building the cloud-native Java application with Open Liberty on Jenkins

Build your Dockerfile from the foundation code given below (gather the additional files mentioned in this code from open liberty support team).

    FROM icr.io/appcafe/open-liberty:full-java11-openj9-ubi
    # Add Liberty server configuration including all necessary features
    COPY --chown=1001:0  server.xml /config/
    # Modify feature repository (optional)
    COPY --chown=1001:0 featureUtility.properties /opt/ol/wlp/etc/
    # This script will add the requested XML snippets to enable Liberty features and grow image to be fit-for-purpose using featureUtility. 
    # Only available in 'kernel-slim'. The 'full' tag already includes all features for convenience.
    RUN features.sh
    # Add interim fixes (optional)
    #COPY --chown=1001:0  interim-fixes /opt/ol/fixes/
    .
    .
    .
    .
    COPY --chown=1001:0 src/main/liberty/config/ /config/
    COPY --chown=1001:0 ./target/*.war /config/apps/
    RUN configure.sh

The following sample pipeline code builds the Liberty Java code, packages it into a Docker image, and pushes the Docker image to a remote Docker image repository, such as DockerHub:

 pipeline {
     agent any
      stages {
       stage('Build') {
                    steps {
              checkout([$class: 'GitSCM', branches: [[name: '*/main']], extensions: [], userRemoteConfigs: [[credentialsId: ‘<git token>, url: 'https://github.com/liberty/app.git']]])
                    sh '''
                         mvn -U package
                         docker login <remote-docker-image-repository-url> -u "${USERNAME}" -p “${PASSWORD}”
                         docker build -t liberty-$<code identifier>:$<docker image version> .
                         #eg: docker build -t liberty-app:v1.0 .
                         docker tag liberty-$<code identifier>:$<docker image version> <remote-docker-image-repository-url>/<docker-repo-name>/liberty-$<code identifier>:$<docker image version>
                         #eg: docker tag liberty-app:v1.0 docker.io/someid/liberty-app:v1.0
                         docker push <remote-docker-image-repository-url>/<docker-repo-name>/liberty-$<code identifier>:$<docker image version>
                         #eg: docker push docker.io/someid/liberty-app:v1.0  
                       '''   
                  }
               }
            }
          }


Following are the parameter that is used in this example code

* git-token is the personal access token you have generated from your Github account.
* remote-docker-image-repository-url is the location of the Docker image repository.
* username is your user name for the Docker image repository.
* password is your password for the Docker image repository.
* docker-image-version is the version number of your Docker image, a unique identifier."

image::/img/blog/jenkins-cred-binding-and-corresponding-param.png[Pipeline credential binding and corresponding param,width=30%,align="center"]

For static code analysis, SonarQube community edition can be used. Install SonarQube server by either using file start-up type from cli by downloading the package in link:https://www.sonarqube.org/success-download-community-edition/[SonarQube server installation package] or use docker way as explained in link:https://docs.sonarqube.org/latest/setup/get-started-2-minutes/[SonarQube server installation steps]. SonarQube jenkins client setup details are given at link:https://docs.sonarqube.org/latest/analysis/scan/sonarscanner-for-jenkins/[SonarQube client for jenkins]. 
 
    CLI command example, integrated with Maven command: 
    $ mvn package verify sonar:sonar -Dsonar.projectKey=sampleapp -Dsonar.host.url=http://localhost:9000 -Dsonar.login=7b13f240123456780479b13d09ba8
   
For Docker image scan, you can use link:https://hub.docker.com/r/aquasec/trivy/[Docker image scan with trivy]. This scan provides the vulnerability details of open source jars that are used in the application. Sample commands are given below

       sh '''
             docker run aquasec/trivy image $docker_login/sampleapp:v1.0
             #eg: docker run aquasec/trivy image docker.io/someid/liberty-app:v1.0
       '''

== Deploying cloud-native Java applications with Open Liberty to Kubernetes with Jenkins

For simplicity, I will use the command line (CLI) option to configure Jenkins to deploy a Jakarta EE & MicroProfile application with Open Liberty to Kubernetes. You could use one of many tools though, such as Helm, Travis CI, Circle CI, etc.

In your pipeline code, add these CLI commands in a new stage. The following sample pipeline code connects to IBM cloud from CLI and then connects to kubernetes cluster running inside that, further it runs all the kubernetes deployment related configurations .
                           
        sh '''
            ibmcloud login --apikey $IBM_CLOUD_API_KEY -g $IBM_CLOUD_RSGRP
            ibmcloud ks cluster config --cluster $CLUSTER-ID
            kubectl config current-context
            kubectl create -f deploy/deployment.yaml #( simple k8s deployment command )
            kubectl create -f deploy/service.yaml #( simple k8s deployment command )
            kubectl create -f deploy/route.yaml #( simple k8s deployment command )
        '''

Make sure that your Kubernetes configuration files are stored in the same git repository as your Jenkinsfile in a sub-directory called deploy, also the docker image name in kubernetes deployment configuration file (as shown in screenshot below) should be updated manually or programmatically (in case of any change in it on run time)

image::/img/blog/deploymentyaml.png[Image reference in deployment yaml,width=40%,align="center"]

When Jenkins has checked out the Java application code for the code build, all the Kubernetes configuration files are also downloaded to the Jenkins workspace so that Jenkins can run the IBM Cloud and Kubernetes commands to connect to the Kubernetes cluster and deploy the application.

See the Kubernetes documentation for other commands
link:https://kubernetes.io/docs/reference/kubectl/cheatsheet/[Kubernetes sample commands].

== QA testing cloud-native Java applications with Jenkins

Apart from running JUnit test cases along with the code build phase, Jenkins can trigger functional and integration QA test cases automatically after deploying the cloud-native Java application.

Configure the test cases on Jenkins job and test it manually. Create a remote job identifier authentication token in "Trigger builds remotely" section under "Build Triggers". Trigger this test case from Docker "entrypoint" file by using remote rest API call that uses this authentication token as the identifier

For example: 

   $ curl -I -u <auth-token> https://<jenkins-host>/job/<job-name>/build?token=<remote-job-identifier-authentication-token>
   
Note: You can generate an authentication token (auth-token) with link:https://www.postman.com[Postman] using the login credentials of Jenkins

== Kubernetes monitoring tools

Kubernetes provides commands to check the application or cluster logs and memory/cpu usage through the commands like 

    $ kubectl logs ..
    $ cat /sys/fs/cgroup/cpu/cpuacct.usage (after connecting to k8s pod)
    $ cat /sys/fs/cgroup/memory/memory.usage_in_bytes (after connecting to k8s pod)

For persistence of logs and usage stats, several applications are available in the market, which can be integrated with Kubernetes, details about some of those apps are given below

These tools are deployed in Kubernetes cluster itself where the application is running and exposed by using route and access the gathered details from UI.

    -> https://grafana.com/oss/loki/
    -> https://medium.com/nerd-for-tech/logging-at-scale-in-kubernetes-using-grafana-loki-3bb2eb0c0872
    -> https://prometheus.io
    -> https://k21academy.com/docker-kubernetes/prometheus-grafana-monitoring/

== Conclusion
There are many ways in which you can configure your DevOps pipeline. This blog post is a quick introduction to how you can use Jenkins to set up a simple CI/CD pipeline to build and deploy your Jakarta EE & MicroProfile applications.