---
layout: post
title: "Continuous integration and delivery (CI/CD) of cloud-native Java applications using Jenkins"
categories: blog
author_picture: https://avatars3.githubusercontent.com/shamjithantholi
author_github: Shamjith Antholi <https://github.com/shamjithantholi>
seo-title: TITLE - OpenLiberty.io
seo-description: DESCRIPTION
blog_description: "A high level explanation about how to build a devops pipeline with Jenkins as the core controller component "
open-graph-image: Twitter <https://openliberty.io/img/twitter_card.jpg>
---
= Continuous integration and delivery (CI/CD) of cloud-native Java applications using Jenkins
Shamjith Antholi <https://github.com/shamjithantholi>
:imagesdir: /
:url-prefix:
:url-about: /

[#Intro]
== DevOps, CI/CD, Jenkins & OpenLiberty ( to deploy Jakarta EE & MicroProfile application)
DevOps is a culture or a process, which enables the integration of the software development (dev) and IT operations (ops). It can facilitate the setup of deployment pipeline and helps to improve the speed of software delivery. Automation of the entire build, test, and deployment of the software applications can be achieved through DevOps process. There are tons of efficient applications and process methodologies available in the market that can be readily integrated to the DevOps pipeline, which can help to achieve the wanted results.

CI/CD are acronym’s for continuous integration, and continuous delivery or deployment used in DevOps. Continuous integration is a process where developers frequently merge code changes into a source code repository, which automatically start code build, security scan, and test execution and deployment. Automation of this process enables organizations to release on a more frequent basis without compromising on quality. There are various tools available to automate the CI/CD process. In this blog post we'll discuss how you can use Jenkins to automate the CI/CD process for building, testing, and deploying your Jakarta EE & MicroProfile applications 

Jenkins is an open source automation server, which helps to automate application code build, test, and deployment. Jenkins comes with a hundred’s of plug-ins, which eases the various DevOps pipeline tool integrations into the DevOps pipeline.

Open Liberty is a lightweight Java runtime for building cloud-native applications and microservices. In this blog, it details how you can use Jenkins in CI/CD pipeline for Jakarta EE & MicroProfile application build/test/deployment (to deploy using Openliberty ) . To try Openliberty link:https://openliberty.io[OpenLiberty] 

The following diagram shows a simple architecture for a pipeline that builds and deploys a Jakarta EE & MicroProfile application in a single Kubernetes environment. When a code change is detected by Jenkins, Jenkins builds the code, runs security and static analysis scans, and runs unit tests against the built code. Jenkins then generates a Docker image of the application with its Open Liberty server and saves the image to a Docker repository, Jenkins then trigger the deployment using CLI commands and deploy the Docker image to Kubernetes..

image::/img/blog/liberty-devops-generic-architecture-2.png[Liberty devops generic architecture diagram ,width=70%,align="center"]

Basic understanding of Git, Docker, Kubernetes are a prerequisite for this blog.

I will assume that you have a basic understanding of git, Docker, Kubernetes. In this blog post, I will assume that the Jakarta EE & MicroProfile application code are stored in link:https://github.com/[Github]. I will use link:https://hub.docker.com/[DockerHub] to store the containerized application (correction: Docker images)and I will deploy the containerized application to link:https://cloud.ibm.com/kubernetes/catalog/create[IBM Cloud Kubernetes Service].

== Installing and configuring Jenkins to setup CI/CD of Jakarta EE & MicroProfile application

Install *jenkins* with all the recommended plug-ins link:https://www.jenkins.io/doc/book/installing/[install Jenkins], make sure that the following plug-ins are installed. You can install Jenkins on any physical or virtual servers, or it can be running as a container on Kubernetes itself.

* Maven
* Pipeline
* Multibranch Scan Webhook Trigger
* Docker
* Kubernetes

Jenkins builds the Jakarta EE & MicroProfile application code by using Jenkins pipeline scripts. The script can run directly on your Jenkins installation (known as Jenkins master) but, if the application is big, you need to use a Jenkins slave agent (good configuration server (or container)). More details about Jenkins slave setup are provided at link:https://www.jenkins.io/doc/book/using/using-agents/[Jenkins slave setup], link:https://www.jenkins.io/doc/book/pipeline/syntax/[pipeline code details] 

== Jenkins pipeline scripting introduction

It is recommended to adhere to the concept of infrastructure as a code (IaaC) in DevOps pipeline, pipeline scripting-based jenkins jobs are a good example of IaaC.

You can write link:https://www.jenkins.io/doc/book/pipeline/syntax/[Jenkins pipeline code] in one of the following ways:

* Directly in the link:https://www.jenkins.io/doc/book/pipeline/getting-started/[Jenkins UI]. This is a useful way to get started. You would need to take a backup of the Jenkins instance to store the pipeline code because it is part of the Jenkins installation. 

image::/img/blog/pipeline-code-on-jenkins.png[Pipeline code directly on Jenkins ,width=70%,align="center"]

* Jenkinsfile (a plain text file) in Git and mapping it to Jenkins. This is better for ensuring that your configuration is always under version control. If you have specific build and deployment configurations for separate environments, such as dev, staging, and production, you create a separate Jenkinsfile for each environment and store it in that environment specific Git repo  branches. You can either use "Pipeline" type job or "Multibranch pipeline" type job in this case.

image::/img/blog/pipeline-code-on-git.png[Pipeline code on Git ,width=50%,align="center"]

== Building the Jakarta EE & MicroProfile application with Open Liberty on Jenkins

Before writing pipeline script to automate the deployment, you need to make a change in Dockerfile. The standard Dockerfile that you use in general may not enough to do the Jakarta EE & MicroProfile application deployment (to OpenLiberty server) on containerized environment. A sample Openliberty compliant Dockerfile snipped in given, you can configure it as needed.

    FROM icr.io/appcafe/open-liberty:full-java11-openj9-ubi
    # Add Liberty server configuration including all necessary features
    COPY --chown=1001:0  server.xml /config/
    # Modify feature repository (optional)
    COPY --chown=1001:0 featureUtility.properties /opt/ol/wlp/etc/
    # This script will add the requested XML snippets to enable Liberty features and grow image to be fit-for-purpose using featureUtility. 
    # Only available in 'kernel-slim'. The 'full' tag already includes all features for convenience.
    RUN features.sh
    # Add interim fixes (optional)
    #COPY --chown=1001:0  interim-fixes /opt/ol/fixes/
    .
    .
    .
    .
    COPY --chown=1001:0 src/main/liberty/config/ /config/
    COPY --chown=1001:0 ./target/*.war /config/apps/
    RUN configure.sh

Below given sample pipeline code can perform the code build, packaging and generating docker image and pushing the same to remote docker hub. You can use it by modifying the parameter section (<>)

 pipeline {
     agent any
      stages {
       stage('Build') {
                    steps {
              checkout([$class: 'GitSCM', branches: [[name: '*/main']], extensions: [], userRemoteConfigs: [[credentialsId: ‘<git token>, url: 'https://github.com/liberty/app.git']]])
                    sh '''
                         mvn -U package
                         docker login <remote-docker-image-repository-url> -u "${USERNAME}" -p “${PASSWORD}”
                         docker build -t liberty-$<code identifier>:$<docker image version> .
                         #eg: docker build -t liberty-app:v1.0 .
                         docker tag liberty-$<code identifier>:$<docker image version> <remote-docker-image-repository-url>/<docker-repo-name>/liberty-$<code identifier>:$<docker image version>
                         #eg: docker tag liberty-app:v1.0 docker.io/someid/liberty-app:v1.0
                         docker push <remote-docker-image-repository-url>/<docker-repo-name>/liberty-$<code identifier>:$<docker image version>
                         #eg: docker push docker.io/someid/liberty-app:v1.0  
                       '''   
                  }
               }
            }
          }


Following are the parameter that is used in this example code

* Git token: Personal access token generated from github.
* remote-docker-image-repository-url : Docker hub repository URL.
* USERNAME/PASSWWORD: username and password to connect to docker registry.

image::/img/blog/jenkins-cred-binding-and-corresponding-param.png[Pipeline credential binding and corresponding param,width=30%,align="center"]

* code identifier: This is optional, a unique docker image identifier
* docker image version: docker image version number, a unique identifier   

*Security scan* can be done along with Maven build command (CLI commands way of application scanning) or can do it in a separate pipeline stage. 

For static code analysis, SonarQube community edition can be used. Install SonarQube server by either using file start-up type from cli by downloading the package in link:https://www.sonarqube.org/success-download-community-edition/[SonarQube server installation package] or use docker way as explained in link:https://docs.sonarqube.org/latest/setup/get-started-2-minutes/[SonarQube server installation steps]. SonarQube jenkins client setup details are given at link:https://docs.sonarqube.org/latest/analysis/scan/sonarscanner-for-jenkins/[SonarQube client for jenkins]. 
 
    CLI command example, integrated with Maven command: 
    $ mvn package verify sonar:sonar -Dsonar.projectKey=sampleapp -Dsonar.host.url=http://localhost:9000 -Dsonar.login=7b13f240123456780479b13d09ba8
   
For Docker image scan, you can use link:https://hub.docker.com/r/aquasec/trivy/[Docker image scan with trivy]. This scan provides the vulnerability details of open source jars that are used in the application. Sample commands are given below

       sh '''
             docker run aquasec/trivy image $docker_login/sampleapp:v1.0
             #eg: docker run aquasec/trivy image docker.io/someid/liberty-app:v1.0
       '''


== Deploying Jakarta EE & MicroProfile applications with Open Liberty to Kubernetes with Jenkins

For simplicity, I will use the command line (CLI) option to configure Jenkins to deploy a Jakarta EE & MicroProfile application with Open Liberty to Kubernetes. You could use one of many tools though, such as Helm, Travis CI, Circle CI, etc.

Create a new stage in the pipeline code and write all the needed commands between the shell option (sample commands give below):
                           
                           sh '''
                              ibmcloud login --apikey $IBM_CLOUD_API_KEY -g $IBM_CLOUD_RSGRP
                              ibmcloud ks cluster config --cluster $CLUSTER-ID
                              kubectl config current-context
                              kubectl create -f deploy/deployment.yaml #( simple k8s deployment command )
                              kubectl create -f deploy/service.yaml #( simple k8s deployment command )
                              kubectl create -f deploy/route.yaml #( simple k8s deployment command )
                           '''

Make sure that your Kubernetes configuration files are in the same source code repository (under a folder called "deploy"), also the image name should be updated manually or programmatically 

image::/img/blog/deploymentyaml.png[Image reference in deployment yaml,width=40%,align="center"]


When Jenkins has checked out the Java application code for the code build, all the Kubernetes configuration files are also downloaded to the Jenkins workspace so that Jenkins can run the IBM Cloud and Kubernetes commands to connect to the Kubernetes cluster and deploy the application.

All the other needed application deployment commands are available in this Kubernetes command page that is straightforward 
link:https://kubernetes.io/docs/reference/kubectl/cheatsheet/[Kubernetes sample commands].

== QA testing, Jakarta EE & MicroProfile applications with Jenkins

Apart from running JUnit test cases along with the code build phase, Jenkins can trigger functional and integration QA test cases automatically after deploying the Jakarta EE & MicroProfile application.

Configure the test cases on jenkins job and test it manually. Create an "Authentication Token" in "Trigger builds remotely" section under "Build Triggers". Trigger this test case from docker "entrypoint" file by using remote rest API call that uses this authentication token as the identifier

For example: curl -I -u <auth-token> https://<jenkins-host>/job/<job-name>/build?token=<authentication-token>
Note: Auth token can be generated from postman

== Kubernetes monitoring tools

Kubernetes provides commands to check the application or cluster logs and memory/cpu usage through the commands like 

    $ kubectl logs ..
    $ cat /sys/fs/cgroup/cpu/cpuacct.usage (after connecting to k8s pod)
    $ cat /sys/fs/cgroup/memory/memory.usage_in_bytes (after connecting to k8s pod)

For persistence of logs and usage stats, several applications are available in the market, which can be integrated with Kubernetes, details about some of those apps are given below

These tools are deployed in Kubernetes cluster itself where the application is running and exposed by using route and access the gathered details from UI.

    -> https://grafana.com/oss/loki/
    -> https://medium.com/nerd-for-tech/logging-at-scale-in-kubernetes-using-grafana-loki-3bb2eb0c0872
    -> https://prometheus.io
    -> https://k21academy.com/docker-kubernetes/prometheus-grafana-monitoring/

== Conclusion
There are many ways in which you can configure your DevOps pipeline. This blog post is a quick introduction to how you can use Jenkins to set up a simple CI/CD pipeline to build and deploy your Jakarta EE & MicroProfile applications.