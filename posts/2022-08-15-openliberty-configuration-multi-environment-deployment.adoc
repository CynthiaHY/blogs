---
layout: post
title: "Managing Open Liberty and MicroProfile configuration files deployment into multiple Kubernetes environments"
categories: blog
author_picture: https://avatars3.githubusercontent.com/shamjithantholi
author_github: https://github.com/shamjithantholi
seo-title: Managing Open Liberty and MicroProfile configuration files deployment into multiple Kubernetes environments
seo-description: Methods to manage Open Liberty and MicroProfile configuration files in multiple Kubernetes environments.
blog_description: Methods to manage Open Liberty and MicroProfile configuration files in multiple Kubernetes environments.
open-graph-image: https://openliberty.io/img/blog/liberty-devops-generic-architecture.png
---
= Managing Open Liberty and MicroProfile configuration files deployment into multiple Kubernetes environments
Shamjith Antholi <https://github.com/shamjithantholi>
:imagesdir: /
:url-prefix:
:url-about: /

[#Intro]

During an application's lifecycle, it is deployed repeatedly into different environments, like development, test, and production. Each environment often requires its own connection details for application components like databases, messaging services etc, and various type of configuration files hosts these connection details. This blog discuss the steps to setup DevOps pipeline to deploy the link:https://microprofile.io[MicroProfile] and link:https://openliberty.io/[Open Liberty] configuration files into these different container based deployment environments. Various application More about MP & OL configuration files can be found in the link:https://github.com/OpenLiberty/blogs/blob/libertydevops-openliberty-microprofile-configuration/posts/2022-08-15-openliberty-microprofile-configuration.adoc[MicroProfile configuration] blog. 

== Managing configurations sources through different environments

Applications deployed on multiple environments like development, test and production have environment-specific configuration files. These environment-specific configurations are managed by developers and operators whose access are limited to the specific environment in which they work, i.e. developer access are limited to development environment, tester access are limited to testing/qa environment, production team access are limited to production environment. The same limitation applies to source code repository/branch as well, development team will be allowed to push the code on only development specific branches ('develop', 'feature-' etc), testing team will be allowed to push the code into testing specific branches only also testing team can merge the development code from develop branch to the testing branch, same pattern are followed on production environment. In some cases, instead of branches, different repositories itself are created for development, qa and production teams, but in this blog we will use multiple branch based pipeline design      

=== Development enviornment 

On DEV environment, all the common config files and DEV-specific config files should be stored in a source control. Ideally, the configuration files are stored on a separate repository from the application source code so that we can achive isolation of code and configs and also we can restrict the code and config access 

On Build tool (like jenkins),  We should create a build job as well as configuration update job. This seperate configuration update job on build tool would be useful when we need to update only the configurations in the container and no application deployment need to be done. Build job will do the application build, scan and packaging and upload the docker image to the image repository. 

The build tool, such as Jenkins, should have both code build job and a separate configuration packaging job. When the source code for the application is updated, both jobs are run. The build job builds, scans, and packages the application, then uploads the Docker image to the image repository, while the configuration job packages and deploys the configuration files deployment environments. However, if only the configuration files are updated, the configuration job can run without building and deploying the whole application as well.

The following diagram shows a typical full build and deployment workflow on the DEV environment. Configuration updates can also be made manually by connecting directly to the running container, though configuration changes should always be committed to version control so that they can be tracked.

Use commands similar to below given to copy files to pods from local
*kubectl cp /tmp/samplefile.txt <container-namespace>/<pod-id>:/tmp/*

image::/img/blog/dev-cluster3.png[Configuration management and deployment on DEV environment ,width=80%,align="center"]

=== 2. Test environment

On Test(QA/UAT) environment, test team can reuse the application docker image which are already used in the development environment. For configuration setup on the QA environment, QA can initiate configuration file deployment from the job in the build tool (as shown in the diagram below) application deployment, QA team can setup the deployment config in the Git repository (get the latest docker image details from development team who is responsible to create it) and execute the same from build tool (like Jenkins) and initiate the redeployment of the image.

To update any configurations from DEV branch to QA branch, DEV team can initiate a pull request and on approval from QA team, it can be merged to QA branch. QA team can directly update any QA environment specific configurations to the configs on QA branch 

image::/img/blog/qa-cluster3.png[Configuration management and deployment on QA environment ,width=80%,align="center"]

=== 3. PROD environment

In the production environment (PROD), the deployment pattern is same as on QA environment. The PROD team can set up the deployment config in the PROD container prior and initiate the redeployment of the image from the build tool or manually. In case of a new image deployment, PROD team can update the new image details in container deployment config manually or programmatically from the build job 

To update any configurations from QA branch to PROD branch, QA team can initiate a pull request and on approval from PROD team, it can be merged to PROD branch. PROD team can directly update any production environment specific configurations to the configs on PROD branch 

image::/img/blog/prod-cluster3.png[Configuration management and deployment on production environment ,width=90%,align="center"]

== Conclusion

Configurations update through volumes can be done using manual shell script executions from container terminal. Many teams do the code build and packaging for QA and PROD deployment as well, like wise there would be alternatives for every methods explained in this blog. This blogs is an opinionated one, please approach it accordingly .
