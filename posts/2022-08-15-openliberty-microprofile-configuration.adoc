---
layout: post
title: "Open Liberty and MicroProfile configuration file management in multiple Kubernetes environments"
categories: blog
author_picture: https://avatars3.githubusercontent.com/shamjithantholi
author_github: https://github.com/shamjithantholi
seo-title: Open Liberty and MicroProfile configuration file management in multiple Kubernetes environments
seo-description: Methods to manage Open Liberty and MicroProfile configuration files in multiple Kubernetes environments.
blog_description: Methods to manage Open Liberty and MicroProfile configuration files in multiple Kubernetes environments.
open-graph-image: https://openliberty.io/img/blog/liberty-devops-generic-architecture.png
---
= Managing configuration through the application lifecycle in Kubernetes environments
Shamjith Antholi <https://github.com/shamjithantholi>
:imagesdir: /
:url-prefix:
:url-about: /

During an application's lifecycle, it is deployed repeatedly into different environments, like development, test, and production. Each environment often requires its own connection details for databases, messaging services, and other services. Your application needs to be able to connect to data sources and other services no matter which environment it is in. Moreover, when deployed to Kubernetes clusters as microservices, the microservices must be able to bind to the correct ports to be able to communicate through, for example, HTTP calls. As instances of microservices are created and destroyed to scale the application up and down in Kubernetes, port numbers are likely to change so you need to be able to programmatically assign new port numbers to the microservices and inject the information during startup without changing the code.

This blog post will discuss how to manage the configuration of an Open Liberty application throughout its lifecycle in development, test, and production Kubernetes environments.

== Managing configurations sources through different environments

Applications deployed on multiple environments like development, test and production have environment-specific configuration files. These environment-specific configurations are managed by developers and operators whose access is limited to the specific environment in which they work.

=== Development environment 

In the development environment (DEV), all of the common configuration files and the DEV-specific configuration files should be stored in source control. Ideally, the configuration files are stored on a separate branch or repository from the application source code so that only people within the DEV environment have access to the source code.

The build tool, such as Jenkins, should have both a build job and a separate configuration build job. When the source code for the application is updated, both jobs are run. The build job builds, scans, and packages the application, then uploads the Docker image to the image repository, while the configuration job packages and deploys the configuration files xxxx. However, if only the configuration files are updated, the configuration job can run without building and deploying the whole application as well.

**Laura: is this right?** 

The following diagram shows a typical full build and deployment workflow on the DEV environment. Configuration updates can also be made manually by connecting directly to the running container, though configuration changes should always be committed to version control so that they can be tracked.

Use commands similar to below given to copy files to pods from local
*kubectl cp /tmp/samplefile.txt <container-namespace>/<pod-id>:/tmp/*

image::/img/blog/dev-cluster1.png[Configuration management and deployment on DEV environment ,width=70%,align="center"]

=== Testing environment

In a testing environment (QA), it's not mandatory to do the code build again. For application deployment, the test team can set up the deployment config in the QA container prior and initiate the redeployment of the image from the build tool. In case of a new image deployment, QA team can update the new image details in container deployment config manually or programmatically from the build job  

**Laura: I don't think I understand what the paragraph above is saying**


To update any configurations from DEV branch to QA branch, DEV team can initiate a pull request and on approval from QA team, it can be merged to QA branch. QA team can directly update any QA environment specific configurations to the configs on QA branch 

image::/img/blog/qa-cluster1.png[Configuration management and deployment on QA environment ,width=70%,align="center"]

=== Production environment

In the production environment (PROD), the deployment pattern is same as on QA environment. The PROD team can set up the deployment config in the PROD container prior and initiate the redeployment of the image from the build tool or manually. In case of a new image deployment, PROD team can update the new image details in container deployment config manually or programmatically from the build job 

To update any configurations from QA branch to PROD branch, QA team can initiate a pull request and on approval from PROD team, it can be merged to PROD branch. PROD team can directly update any production environment specific configurations to the configs on PROD branch 

image::/img/blog/prod-cluster1.png[Configuration management and deployment on production environment ,width=70%,align="center"]

== Conclusion

Configurations update through volumes can be done using manual shell script executions from container terminal. Many teams do the code build and packaging for QA and PROD deployment as well, like wise there would be alternatives for every methods explained in this blog. This blogs is an opinionated one, please approach it accordingly .