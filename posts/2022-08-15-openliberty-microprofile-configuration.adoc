---
layout: post
title: "Open Liberty and MicroProfile configuration file management in multiple Kubernetes environments"
categories: blog
author_picture: https://avatars3.githubusercontent.com/shamjithantholi
author_github: https://github.com/shamjithantholi
seo-title: Open Liberty and MicroProfile configuration file management in multiple Kubernetes environments
seo-description: Methods to manage Open Liberty and MicroProfile configuration files in multiple Kubernetes environments.
blog_description: Methods to manage Open Liberty and MicroProfile configuration files in multiple Kubernetes environments.
open-graph-image: https://openliberty.io/img/blog/liberty-devops-generic-architecture.png
---
= Open Liberty and MicroProfile configuration file management in multiple Kubernetes environments
Shamjith Antholi <https://github.com/shamjithantholi>
:imagesdir: /
:url-prefix:
:url-about: /

[#Intro]

== What is MicroProfile and Open Liberty

The link:https://microprofile.io[MicroProfile] specification consists of a collection of Enterprise Java APIs and technologies that together form a core baseline for microservices that aims to deliver application portability across multiple runtimes.

link:https://openliberty.io/?_ga=2.75178834.1545551050.1658778682-1210051418.1658778682[Open Liberty] is a lightweight open source Javaâ„¢ runtime that is built by using modular features. link:https://www.ibm.com/cloud/websphere-liberty[WebSphere Liberty] is a commercial version of Open Liberty.

== About MicroProfile config and containerization

Externalization of constants into different file formats like .java, .properties, .xml etc are a common coding practice to separete application code from the configuration variables. Variables in the source code are resolved from these 'constants' files on run time. In this blog, we will be discussing how Open Liberty and MicroProfile manages such externalization requirements.  

MicroProfile and Open Liberty have standardized the use of these parameter files with additional properties like ordianls. Different type of files where the constants and run time variables can be hosted are 

             server.xml
             Environment based files/variables in source code
             microprofile-config.properties
             bootstrap.properties
             CustomConfig properties (anything which implement org.eclipse.microprofile.config.spi.ConfigSource)

All these property files contains an ordinal value to set the reading order of the file by the application. 

Applications need to be hosted on multiple environments like development, test and production. There will be several variables whose values would be changing across these environments and containerized platforms has different configuration methods like given below to inject the variable values on run time to the application.

            Configuring through environment variables
            Configuring through ConfigMap
            Configuring through Secrets
            Configuring through configuration file in a volume

When values of variables configured on environment variable, configmap and secrets are changed, application pod will be restarted to complete the injection, but that's not the case with configuration through volume. 

Architecture diagram of Open Liberty config files flow from GitHub through a build tool to Kubernetes is as given below

image::/img/blog/ol-configuration.png[Open Liberty configuration file flow,width=70%,align="left"]

== Different data injection methods in Kubernetes/OpenShift

There are multiple ways to inject data into application containers. This blog will discuss those methods one by one. The commands given in this blogs are OpenShift commands, but you can run the same on Kubernetes by replacing 'oc' by 'kubeclt'

For the purpose of demonstration, i have defined variables in below given files and the values for the same is injected from different container data sources.

server.xml&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;microprofile-config.properties

[cols=">a,<a", frame=none, grid=none]
|===
| image::/img/blog/server-xml.png[server.xml file variable view,width=70%,align="left"]
| image::/img/blog/microprofile.png[MicroProfile config file variable view,width=70%,align="right"]
|===

botstrap.properties&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server.env

[cols=">a,<a", frame=none, grid=none]
|===
| image::/img/blog/bootstrap.png[bootstrap.properties file variable view,width=70%,align="left"]
| image::/img/blog/server-env.png[server.env file variable view,width=70%,align="right"]
|===

CustomConfigSource.json

[cols=">a,<a", frame=none, grid=none]
|===
| image::/img/blog/customconfigsource.png[Custom config source file variable view,width=70%,align="left"]
| 
|===



=== Configuring through environment variables

Container pods can define environment variables in deployment configuration. Users can configure these environment variables to use it in the application on run time. 

In this section, i will demonstrate how to configure the environment variables in container environment, from UI as well as from deployment configuration yaml code. Users can change these environment variables either manually or automated to feed the new variable values into the container (when environment variable is changed, associated pod will be restarted).

image::/img/blog/OpenShift-deployment.png[OpenShift environment variable view,width=70%,align="center"]

        containers:
          - resources: {}
            terminationMessagePath: /dev/termination-log
            name: libertyapp
            env:
              - name: MPConfig
                value: micro profile  test config
              - name: SerEnv
                value: server env test config
              - name: Custom-Config
                value: Custom config param
              - name: Server-Config
                value: server config
              - name: Boot-config
                value: boot config
            ports:
              - containerPort: 9080

When the container is restarted, the values from this environment variables are injected into application in the container, a sample result is show below

image::/img/blog/env-variable-results.png[Environment variable result view,width=100%,align="center"]

=== Config Map

A ConfigMap is a configuration store in containerization platform. It store configurations in key-value format. These configmap's can be injected into container pods which will be used by the hosted application on run time. 

In this section i will explain the steps to create configmap and configure the same on container to inject the values into the hosted application.

Create a configmap in Kubernetes/OpenShift

            apiVersion: v1
            kind: ConfigMap
            metadata:
              name: config-env-file
            data:
              MPConfig: "micro profile  test config"
              SerEnv: "server env test config"
              Custom-Config: "Custom config param"
              Server-Config: "server config"
              Boot-config: "boot config"

            oc create -f configmap.yaml 

ConfigMap is created in Kubernetes/OpenShift

[cols=">a,<a", frame=none, grid=none]
|===
| image::/img/blog/configmap-in-oc1.png[ConfigMap openshift view1,width=70%,align="center"]
| image::/img/blog/configmap-in-oc2.png[ConfigMap openshift view2,width=70%,align="center"]
|===

Now map the configmap to the container pod for the injecting into the associated application 

From UI:

image::/img/blog/configmap-env-mapping.png[ConfigMap - environment variable mapping view,width=50%,align="center"]


YAML defenition

          containers:
            - resources: {}
              terminationMessagePath: /dev/termination-log
              name: libertyapp
              env:
                - name: MPConfig
                  valueFrom:
                    configMapKeyRef:
                      name: config-env-file
                      key: MPConfig
                - name: SerEnv
                  valueFrom:
                    configMapKeyRef:
                      name: config-env-file
                      key: SerEnv
              ports:
                - containerPort: 9080
                  protocol: TCP


=== Config as Secrets

OpenShift/Kubernetes secrets can be used to inject dynamic values into hosted applications. +

Create an OpenShift/Kubernetes secret following the steps in link:https://docs.openshift.com/container-platform/3.11/dev_guide/secrets.html[create secret]

image::/img/blog/oc-config.png[OpenShift secret view,width=40%,align="center"]

Map the secret to environment variable as the data source and access the variable from the application.

[cols=">a,<a", frame=none, grid=none]
|===
| image::/img/blog/secrets-as-config.png[OpenShift secret as config view,width=100%,align="left"]
| image::/img/blog/oc-secret-config-result.png[ConfigMap as secret result view,width=100%,align="right"]
|===

=== Config file in Volumes - Avoiding application restart

Another common configuration management process in containerized infrastructure are maintaining the config file on a mapped volume and processing it whenever required to extract the required parameter values. These files can be replaced manually or automated for injecting a new set of data into container. Files copied onto volume can be processed on demand or application can implement a timer task to process it on a fixed interval.

image::/img/blog/config-in-volume-mount.png[ConfigMap in volume - yaml view ,width=70%,align="center"]

== Managing configurations files through different Kubernetes environments

#Github branches

#pull requests

== Conclusion

